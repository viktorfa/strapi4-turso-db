diff --git a/dist/index.js b/dist/index.js
index d25fec78d2c41d9f94fb0bf435bbc19e6d68ea73..727cdafec0c46a22b8f445b19def11d7ba5d7996 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -18,19 +18,24 @@ const umzug = require("umzug");
 const assert = require("assert");
 const knex = require("knex");
 const SqliteClient = require("knex/lib/dialects/sqlite3/index");
-const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
+const _interopDefault = (e) => (e && e.__esModule ? e : { default: e });
 function _interopNamespace(e) {
-  if (e && e.__esModule)
-    return e;
+  if (e && e.__esModule) return e;
   const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
   if (e) {
     for (const k in e) {
       if (k !== "default") {
         const d = Object.getOwnPropertyDescriptor(e, k);
-        Object.defineProperty(n, k, d.get ? d : {
-          enumerable: true,
-          get: () => e[k]
-        });
+        Object.defineProperty(
+          n,
+          k,
+          d.get
+            ? d
+            : {
+                enumerable: true,
+                get: () => e[k],
+              }
+        );
       }
     }
   }
@@ -58,10 +63,8 @@ class Dialect {
     this.db = db;
     this.client = client;
   }
-  configure() {
-  }
-  initialize() {
-  }
+  configure() {}
+  initialize() {}
   getSqlType(type) {
     return type;
   }
@@ -83,10 +86,8 @@ class Dialect {
   supportsOperator() {
     return true;
   }
-  async startSchemaUpdate() {
-  }
-  async endSchemaUpdate() {
-  }
+  async startSchemaUpdate() {}
+  async endSchemaUpdate() {}
   transformErrors(error) {
     if (error instanceof Error) {
       throw error;
@@ -97,6 +98,18 @@ class Dialect {
     return true;
   }
 }
+
+const Client_SQLite3 = require("knex/lib/dialects/sqlite3");
+class Client_Libsql extends Client_SQLite3 {
+  _driver() {
+    return require("@libsql/sqlite3");
+  }
+}
+Object.assign(Client_Libsql.prototype, {
+  dialect: "libsql",
+  driverName: "libsql",
+});
+
 class DatabaseError extends Error {
   details;
   constructor(message = "A database error occured", details = {}) {
@@ -108,7 +121,9 @@ class DatabaseError extends Error {
 }
 class NotNullError extends DatabaseError {
   constructor({ column = "" } = {}) {
-    super(`Not null constraint violation${column ? ` on column ${column}` : ""}.`);
+    super(
+      `Not null constraint violation${column ? ` on column ${column}` : ""}.`
+    );
     this.name = "NotNullError";
     this.details = { column };
     this.stack = "";
@@ -138,17 +153,23 @@ class InvalidRelationError extends DatabaseError {
     this.name = "InvalidRelationFormat";
   }
 }
-const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
-  __proto__: null,
-  DatabaseError,
-  InvalidDateError,
-  InvalidDateTimeError,
-  InvalidRelationError,
-  InvalidTimeError,
-  NotNullError
-}, Symbol.toStringTag, { value: "Module" }));
+const index = /* @__PURE__ */ Object.freeze(
+  /* @__PURE__ */ Object.defineProperty(
+    {
+      __proto__: null,
+      DatabaseError,
+      InvalidDateError,
+      InvalidDateTimeError,
+      InvalidRelationError,
+      InvalidTimeError,
+      NotNullError,
+    },
+    Symbol.toStringTag,
+    { value: "Module" }
+  )
+);
 const SQL_QUERIES$3 = {
-  TABLE_LIST: (
+  TABLE_LIST:
     /* sql */
     `
     SELECT *
@@ -158,17 +179,15 @@ const SQL_QUERIES$3 = {
       AND table_type = 'BASE TABLE'
       AND table_name != 'geometry_columns'
       AND table_name != 'spatial_ref_sys';
-  `
-  ),
-  LIST_COLUMNS: (
+  `,
+  LIST_COLUMNS:
     /* sql */
     `
     SELECT data_type, column_name, character_maximum_length, column_default, is_nullable
     FROM information_schema.columns
     WHERE table_schema = ? AND table_name = ?;
-  `
-  ),
-  INDEX_LIST: (
+  `,
+  INDEX_LIST:
     /* sql */
     `
     SELECT
@@ -192,9 +211,8 @@ const SQL_QUERIES$3 = {
       AND t.relnamespace = s.oid
       AND s.nspname = ?
       AND t.relname = ?;
-  `
-  ),
-  FOREIGN_KEY_LIST: (
+  `,
+  FOREIGN_KEY_LIST:
     /* sql */
     `
     SELECT
@@ -204,9 +222,8 @@ const SQL_QUERIES$3 = {
       tco.constraint_type = 'FOREIGN KEY'
       AND tco.constraint_schema = ?
       AND tco.table_name = ?
-  `
-  ),
-  FOREIGN_KEY_REFERENCES: (
+  `,
+  FOREIGN_KEY_REFERENCES:
     /* sql */
     `
     SELECT
@@ -217,9 +234,8 @@ const SQL_QUERIES$3 = {
     WHERE kcu.constraint_name=ANY(?)
     AND kcu.table_schema = ?
     AND kcu.table_name = ?;
-  `
-  ),
-  FOREIGN_KEY_REFERENCES_CONSTRAIN: (
+  `,
+  FOREIGN_KEY_REFERENCES_CONSTRAIN:
     /* sql */
     `
   SELECT
@@ -229,9 +245,8 @@ const SQL_QUERIES$3 = {
   FROM information_schema.referential_constraints rco
   WHERE rco.constraint_name=ANY(?)
   AND rco.constraint_schema = ?
-`
-  ),
-  FOREIGN_KEY_REFERENCES_CONSTRAIN_RFERENCE: (
+`,
+  FOREIGN_KEY_REFERENCES_CONSTRAIN_RFERENCE:
     /* sql */
     `
   SELECT
@@ -240,8 +255,7 @@ const SQL_QUERIES$3 = {
     FROM information_schema.key_column_usage rel_kcu
     WHERE rel_kcu.constraint_name=?
     AND rel_kcu.table_schema = ?
-`
-  )
+`,
 };
 const toStrapiType$2 = (column) => {
   const rootType = column.data_type.toLowerCase().match(/[^(), ]+/)?.[0];
@@ -310,7 +324,7 @@ class PostgresqlSchemaInspector {
           name: tableName,
           columns,
           indexes,
-          foreignKeys
+          foreignKeys,
         };
       })
     );
@@ -321,18 +335,21 @@ class PostgresqlSchemaInspector {
   }
   async getTables() {
     const { rows } = await this.db.connection.raw(SQL_QUERIES$3.TABLE_LIST, [
-      this.getDatabaseSchema()
+      this.getDatabaseSchema(),
     ]);
     return rows.map((row) => row.table_name);
   }
   async getColumns(tableName) {
     const { rows } = await this.db.connection.raw(SQL_QUERIES$3.LIST_COLUMNS, [
       this.getDatabaseSchema(),
-      tableName
+      tableName,
     ]);
     return rows.map((row) => {
       const { type, args = [], ...rest } = toStrapiType$2(row);
-      const defaultTo = row.column_default && row.column_default.includes("nextval(") ? null : row.column_default;
+      const defaultTo =
+        row.column_default && row.column_default.includes("nextval(")
+          ? null
+          : row.column_default;
       return {
         type,
         args,
@@ -340,14 +357,14 @@ class PostgresqlSchemaInspector {
         name: row.column_name,
         notNullable: row.is_nullable === "NO",
         unsigned: false,
-        ...rest
+        ...rest,
       };
     });
   }
   async getIndexes(tableName) {
     const { rows } = await this.db.connection.raw(SQL_QUERIES$3.INDEX_LIST, [
       this.getDatabaseSchema(),
-      tableName
+      tableName,
     ]);
     const ret = {};
     for (const index2 of rows) {
@@ -358,7 +375,7 @@ class PostgresqlSchemaInspector {
         ret[index2.indexrelid] = {
           columns: [index2.column_name],
           name: index2.index_name,
-          type: getIndexType(index2)
+          type: getIndexType(index2),
         };
       } else {
         ret[index2.indexrelid].columns.push(index2.column_name);
@@ -379,7 +396,7 @@ class PostgresqlSchemaInspector {
         referencedColumns: [],
         referencedTable: null,
         onUpdate: null,
-        onDelete: null
+        onDelete: null,
       };
     }
     const constraintNames = Object.keys(ret);
@@ -396,18 +413,22 @@ class PostgresqlSchemaInspector {
           [[fkReference.constraint_name], dbSchema]
         );
         for (const fkReferenceC of fkReferencesConstraint) {
-          const { rows: fkReferencesConstraintReferece } = await this.db.connection.raw(
-            SQL_QUERIES$3.FOREIGN_KEY_REFERENCES_CONSTRAIN_RFERENCE,
-            [fkReferenceC.unique_constraint_name, dbSchema]
-          );
+          const { rows: fkReferencesConstraintReferece } =
+            await this.db.connection.raw(
+              SQL_QUERIES$3.FOREIGN_KEY_REFERENCES_CONSTRAIN_RFERENCE,
+              [fkReferenceC.unique_constraint_name, dbSchema]
+            );
           for (const fkReferenceConst of fkReferencesConstraintReferece) {
-            ret[fkReference.constraint_name].referencedTable = fkReferenceConst.foreign_table;
+            ret[fkReference.constraint_name].referencedTable =
+              fkReferenceConst.foreign_table;
             ret[fkReference.constraint_name].referencedColumns.push(
               fkReferenceConst.fk_column_name
             );
           }
-          ret[fkReference.constraint_name].onUpdate = fkReferenceC.on_update.toUpperCase();
-          ret[fkReference.constraint_name].onDelete = fkReferenceC.on_delete.toUpperCase();
+          ret[fkReference.constraint_name].onUpdate =
+            fkReferenceC.on_update.toUpperCase();
+          ret[fkReference.constraint_name].onDelete =
+            fkReferenceC.on_delete.toUpperCase();
         }
       }
     }
@@ -457,7 +478,7 @@ class PostgresDialect extends Dialect {
     switch (error.code) {
       case "23502": {
         throw new NotNullError({
-          column: "column" in error ? `${error.column}` : void 0
+          column: "column" in error ? `${error.column}` : void 0,
         });
       }
       default: {
@@ -467,7 +488,7 @@ class PostgresDialect extends Dialect {
   }
 }
 const SQL_QUERIES$2 = {
-  TABLE_LIST: (
+  TABLE_LIST:
     /* sql */
     `
     SELECT
@@ -475,9 +496,8 @@ const SQL_QUERIES$2 = {
     FROM information_schema.tables t
     WHERE table_type = 'BASE TABLE'
     AND table_schema = schema();
-  `
-  ),
-  LIST_COLUMNS: (
+  `,
+  LIST_COLUMNS:
     /* sql */
     `
     SELECT
@@ -491,15 +511,13 @@ const SQL_QUERIES$2 = {
     FROM information_schema.columns c
     WHERE table_schema = database()
     AND table_name = ?;
-  `
-  ),
-  INDEX_LIST: (
+  `,
+  INDEX_LIST:
     /* sql */
     `
     show index from ??;
-  `
-  ),
-  FOREIGN_KEY_LIST: (
+  `,
+  FOREIGN_KEY_LIST:
     /* sql */
     `
     SELECT
@@ -508,9 +526,8 @@ const SQL_QUERIES$2 = {
     WHERE tc.constraint_type = 'FOREIGN KEY'
     AND tc.table_schema = database()
     AND tc.table_name = ?;
-  `
-  ),
-  FOREIGN_KEY_REFERENCES: (
+  `,
+  FOREIGN_KEY_REFERENCES:
     /* sql */
     `
     SELECT
@@ -522,9 +539,8 @@ const SQL_QUERIES$2 = {
     WHERE kcu.constraint_name in (?)
     AND kcu.table_schema = database()
     AND kcu.table_name = ?;
-  `
-  ),
-  FOREIGN_KEY_REFERENTIALS_CONSTRAINTS: (
+  `,
+  FOREIGN_KEY_REFERENTIALS_CONSTRAINTS:
     /* sql */
     `
     SELECT
@@ -535,15 +551,18 @@ const SQL_QUERIES$2 = {
     WHERE rc.constraint_name in (?)
     AND rc.constraint_schema = database()
     AND rc.table_name = ?;
-  `
-  )
+  `,
 };
 const toStrapiType$1 = (column) => {
   const rootType = column.data_type.toLowerCase().match(/[^(), ]+/)?.[0];
   switch (rootType) {
     case "int": {
       if (column.column_key === "PRI") {
-        return { type: "increments", args: [{ primary: true, primaryKey: true }], unsigned: false };
+        return {
+          type: "increments",
+          args: [{ primary: true, primaryKey: true }],
+          unsigned: false,
+        };
       }
       return { type: "integer" };
     }
@@ -605,7 +624,7 @@ class MysqlSchemaInspector {
           name: tableName,
           columns,
           indexes,
-          foreignKeys
+          foreignKeys,
         };
       })
     );
@@ -617,7 +636,7 @@ class MysqlSchemaInspector {
   }
   async getColumns(tableName) {
     const [rows] = await this.db.connection.raw(SQL_QUERIES$2.LIST_COLUMNS, [
-      tableName
+      tableName,
     ]);
     return rows.map((row) => {
       const { type, args = [], ...rest } = toStrapiType$1(row);
@@ -628,12 +647,14 @@ class MysqlSchemaInspector {
         name: row.column_name,
         notNullable: row.is_nullable === "NO",
         unsigned: row.column_type.endsWith(" unsigned"),
-        ...rest
+        ...rest,
       };
     });
   }
   async getIndexes(tableName) {
-    const [rows] = await this.db.connection.raw(SQL_QUERIES$2.INDEX_LIST, [tableName]);
+    const [rows] = await this.db.connection.raw(SQL_QUERIES$2.INDEX_LIST, [
+      tableName,
+    ]);
     const ret = {};
     for (const index2 of rows) {
       if (index2.Column_name === "id") {
@@ -642,7 +663,7 @@ class MysqlSchemaInspector {
       if (!ret[index2.Key_name]) {
         const indexInfo = {
           columns: [index2.Column_name],
-          name: index2.Key_name
+          name: index2.Key_name,
         };
         if (!index2.Non_unique) {
           indexInfo.type = "unique";
@@ -655,9 +676,10 @@ class MysqlSchemaInspector {
     return Object.values(ret);
   }
   async getForeignKeys(tableName) {
-    const [rows] = await this.db.connection.raw(SQL_QUERIES$2.FOREIGN_KEY_LIST, [
-      tableName
-    ]);
+    const [rows] = await this.db.connection.raw(
+      SQL_QUERIES$2.FOREIGN_KEY_LIST,
+      [tableName]
+    );
     const ret = {};
     for (const fk of rows) {
       ret[fk.constraint_name] = {
@@ -666,27 +688,32 @@ class MysqlSchemaInspector {
         referencedColumns: [],
         referencedTable: null,
         onUpdate: null,
-        onDelete: null
+        onDelete: null,
       };
     }
     const contraintNames = Object.keys(ret);
     if (contraintNames.length > 0) {
-      const [fkReferences] = await this.db.connection.raw(SQL_QUERIES$2.FOREIGN_KEY_REFERENCES, [
-        contraintNames,
-        tableName
-      ]);
+      const [fkReferences] = await this.db.connection.raw(
+        SQL_QUERIES$2.FOREIGN_KEY_REFERENCES,
+        [contraintNames, tableName]
+      );
       for (const fkReference of fkReferences) {
-        ret[fkReference.constraint_name].referencedTable = fkReference.referenced_table_name;
+        ret[fkReference.constraint_name].referencedTable =
+          fkReference.referenced_table_name;
         ret[fkReference.constraint_name].columns.push(fkReference.column_name);
-        ret[fkReference.constraint_name].referencedColumns.push(fkReference.referenced_column_name);
+        ret[fkReference.constraint_name].referencedColumns.push(
+          fkReference.referenced_column_name
+        );
       }
       const [fkReferentialConstraints] = await this.db.connection.raw(
         SQL_QUERIES$2.FOREIGN_KEY_REFERENTIALS_CONSTRAINTS,
         [contraintNames, tableName]
       );
       for (const fkReferentialConstraint of fkReferentialConstraints) {
-        ret[fkReferentialConstraint.constraint_name].onUpdate = fkReferentialConstraint.on_update.toUpperCase();
-        ret[fkReferentialConstraint.constraint_name].onDelete = fkReferentialConstraint.on_delete.toUpperCase();
+        ret[fkReferentialConstraint.constraint_name].onUpdate =
+          fkReferentialConstraint.on_update.toUpperCase();
+        ret[fkReferentialConstraint.constraint_name].onDelete =
+          fkReferentialConstraint.on_delete.toUpperCase();
       }
     }
     return Object.values(ret);
@@ -695,7 +722,7 @@ class MysqlSchemaInspector {
 const MYSQL = "MYSQL";
 const MARIADB = "MARIADB";
 const SQL_QUERIES$1 = {
-  VERSION: `SELECT version() as version`
+  VERSION: `SELECT version() as version`,
 };
 class MysqlDatabaseInspector {
   db;
@@ -710,16 +737,19 @@ class MysqlDatabaseInspector {
       const versionSplit = results[0].version.split("-");
       const databaseName = versionSplit[1];
       versionNumber = versionSplit[0];
-      database = databaseName && databaseName.toLowerCase() === "mariadb" ? MARIADB : MYSQL;
+      database =
+        databaseName && databaseName.toLowerCase() === "mariadb"
+          ? MARIADB
+          : MYSQL;
     } catch (e) {
       return {
         database: null,
-        version: null
+        version: null,
       };
     }
     return {
       database,
-      version: versionNumber
+      version: versionNumber,
     };
   }
 }
@@ -756,16 +786,14 @@ class MysqlDialect extends Dialect {
   async initialize() {
     try {
       await this.db.connection.raw(`set session sql_require_primary_key = 0;`);
-    } catch (err) {
-    }
+    } catch (err) {}
     this.info = await this.databaseInspector.getInformation();
   }
   async startSchemaUpdate() {
     try {
       await this.db.connection.raw(`set foreign_key_checks = 0;`);
       await this.db.connection.raw(`set session sql_require_primary_key = 0;`);
-    } catch (err) {
-    }
+    } catch (err) {}
   }
   async endSchemaUpdate() {
     await this.db.connection.raw(`set foreign_key_checks = 1;`);
@@ -775,7 +803,9 @@ class MysqlDialect extends Dialect {
   }
   supportsWindowFunctions() {
     const isMysqlDB = !this.info?.database || this.info.database === MYSQL;
-    const isBeforeV8 = !semver__default.default.valid(this.info?.version) || semver__default.default.lt(this.info?.version ?? "", "8.0.0");
+    const isBeforeV8 =
+      !semver__default.default.valid(this.info?.version) ||
+      semver__default.default.lt(this.info?.version ?? "", "8.0.0");
     if (isMysqlDB && isBeforeV8) {
       return false;
     }
@@ -793,7 +823,7 @@ const SQL_QUERIES = {
   TABLE_INFO: `pragma table_info(??)`,
   INDEX_LIST: "pragma index_list(??)",
   INDEX_INFO: "pragma index_info(??)",
-  FOREIGN_KEY_LIST: "pragma foreign_key_list(??)"
+  FOREIGN_KEY_LIST: "pragma foreign_key_list(??)",
 };
 const toStrapiType = (column) => {
   const { type } = column;
@@ -801,7 +831,10 @@ const toStrapiType = (column) => {
   switch (rootType) {
     case "integer": {
       if (column.pk) {
-        return { type: "increments", args: [{ primary: true, primaryKey: true }] };
+        return {
+          type: "increments",
+          args: [{ primary: true, primaryKey: true }],
+        };
       }
       return { type: "integer" };
     }
@@ -854,7 +887,7 @@ class SqliteSchemaInspector {
         name: tableName,
         columns,
         indexes,
-        foreignKeys
+        foreignKeys,
       });
     }
     return schema;
@@ -864,7 +897,9 @@ class SqliteSchemaInspector {
     return rows.map((row) => row.name);
   }
   async getColumns(tableName) {
-    const rows = await this.db.connection.raw(SQL_QUERIES.TABLE_INFO, [tableName]);
+    const rows = await this.db.connection.raw(SQL_QUERIES.TABLE_INFO, [
+      tableName,
+    ]);
     return rows.map((row) => {
       const { type, args = [], ...rest } = toStrapiType(row);
       return {
@@ -874,20 +909,24 @@ class SqliteSchemaInspector {
         defaultTo: row.dflt_value,
         notNullable: row.notnull !== null ? Boolean(row.notnull) : null,
         unsigned: false,
-        ...rest
+        ...rest,
       };
     });
   }
   async getIndexes(tableName) {
-    const indexes = await this.db.connection.raw(SQL_QUERIES.INDEX_LIST, [tableName]);
+    const indexes = await this.db.connection.raw(SQL_QUERIES.INDEX_LIST, [
+      tableName,
+    ]);
     const ret = [];
-    for (const index2 of indexes.filter((index22) => !index22.name.startsWith("sqlite_"))) {
+    for (const index2 of indexes.filter(
+      (index22) => !index22.name.startsWith("sqlite_")
+    )) {
       const res = await this.db.connection.raw(SQL_QUERIES.INDEX_INFO, [
-        index2.name
+        index2.name,
       ]);
       const indexInfo = {
         columns: res.map((row) => row.name),
-        name: index2.name
+        name: index2.name,
       };
       if (index2.unique) {
         indexInfo.type = "unique";
@@ -898,7 +937,7 @@ class SqliteSchemaInspector {
   }
   async getForeignKeys(tableName) {
     const fks = await this.db.connection.raw(SQL_QUERIES.FOREIGN_KEY_LIST, [
-      tableName
+      tableName,
     ]);
     const ret = {};
     for (const fk of fks) {
@@ -910,7 +949,7 @@ class SqliteSchemaInspector {
           referencedColumns: [fk.to],
           referencedTable: fk.table,
           onUpdate: fk.on_update.toUpperCase(),
-          onDelete: fk.on_delete.toUpperCase()
+          onDelete: fk.on_delete.toUpperCase(),
         };
       } else {
         ret[fk.id].columns.push(fk.from);
@@ -984,6 +1023,14 @@ class SqliteDialect extends Dialect {
     return false;
   }
 }
+class LibsqlDialect extends SqliteDialect {
+  schemaInspector;
+  constructor(db) {
+    super(db);
+    this.client = "libsql";
+  }
+  configure() {}
+}
 const getDialectClass = (client) => {
   switch (client) {
     case "postgres":
@@ -992,6 +1039,8 @@ const getDialectClass = (client) => {
       return MysqlDialect;
     case "sqlite":
       return SqliteDialect;
+    case "libsql":
+      return LibsqlDialect;
     default:
       throw new Error(`Unknown dialect ${client}`);
   }
@@ -1000,6 +1049,8 @@ const getDialectName = (client) => {
   switch (client) {
     case "postgres":
       return "postgres";
+    case "libsql":
+      return "libsql";
     case "mysql":
     case "mysql2":
       return "mysql";
@@ -1096,13 +1147,27 @@ const createSchemaBuilder = (db) => {
         }
       });
       await db.dialect.endSchemaUpdate();
-    }
+    },
   };
 };
 const createHelpers = (db) => {
   const createForeignKey = (tableBuilder, foreignKey) => {
-    const { name, columns, referencedColumns, referencedTable, onDelete, onUpdate } = foreignKey;
-    const constraint = tableBuilder.foreign(columns, name).references(referencedColumns).inTable(db.getSchemaName() ? `${db.getSchemaName()}.${referencedTable}` : referencedTable);
+    const {
+      name,
+      columns,
+      referencedColumns,
+      referencedTable,
+      onDelete,
+      onUpdate,
+    } = foreignKey;
+    const constraint = tableBuilder
+      .foreign(columns, name)
+      .references(referencedColumns)
+      .inTable(
+        db.getSchemaName()
+          ? `${db.getSchemaName()}.${referencedTable}`
+          : referencedTable
+      );
     if (onDelete) {
       constraint.onDelete(onDelete);
     }
@@ -1174,11 +1239,15 @@ const createHelpers = (db) => {
   };
   const createTable2 = async (schemaBuilder, table) => {
     await schemaBuilder.createTable(table.name, (tableBuilder) => {
-      (table.columns || []).forEach((column) => createColumn2(tableBuilder, column));
-      (table.indexes || []).forEach((index2) => createIndex(tableBuilder, index2));
+      (table.columns || []).forEach((column) =>
+        createColumn2(tableBuilder, column)
+      );
+      (table.indexes || []).forEach((index2) =>
+        createIndex(tableBuilder, index2)
+      );
       if (!db.dialect.canAlterConstraints()) {
-        (table.foreignKeys || []).forEach(
-          (foreignKey) => createForeignKey(tableBuilder, foreignKey)
+        (table.foreignKeys || []).forEach((foreignKey) =>
+          createForeignKey(tableBuilder, foreignKey)
         );
       }
     });
@@ -1224,7 +1293,10 @@ const createHelpers = (db) => {
       }
       for (const addedColumn of table.columns.added) {
         debug$1(`Creating column ${addedColumn.name}`);
-        if (addedColumn.type === "increments" && !db.dialect.canAddIncrements()) {
+        if (
+          addedColumn.type === "increments" &&
+          !db.dialect.canAddIncrements()
+        ) {
           tableBuilder.integer(addedColumn.name).unsigned();
           tableBuilder.primary([addedColumn.name]);
         } else {
@@ -1249,7 +1321,9 @@ const createHelpers = (db) => {
   };
   const createTableForeignKeys = async (schemaBuilder, table) => {
     await schemaBuilder.table(table.name, (tableBuilder) => {
-      (table.foreignKeys || []).forEach((foreignKey) => createForeignKey(tableBuilder, foreignKey));
+      (table.foreignKeys || []).forEach((foreignKey) =>
+        createForeignKey(tableBuilder, foreignKey)
+      );
     });
   };
   const dropTableForeignKeys = async (schemaBuilder, table) => {
@@ -1257,7 +1331,9 @@ const createHelpers = (db) => {
       return;
     }
     await schemaBuilder.table(table.name, (tableBuilder) => {
-      (table.foreignKeys || []).forEach((foreignKey) => dropForeignKey(tableBuilder, foreignKey));
+      (table.foreignKeys || []).forEach((foreignKey) =>
+        dropForeignKey(tableBuilder, foreignKey)
+      );
     });
   };
   return {
@@ -1265,13 +1341,13 @@ const createHelpers = (db) => {
     alterTable,
     dropTable,
     createTableForeignKeys,
-    dropTableForeignKeys
+    dropTableForeignKeys,
   };
 };
 const RESERVED_TABLE_NAMES = ["strapi_migrations", "strapi_database_schema"];
 const statuses = {
   CHANGED: "CHANGED",
-  UNCHANGED: "UNCHANGED"
+  UNCHANGED: "UNCHANGED",
 };
 const helpers = {
   hasTable(schema, tableName) {
@@ -1281,23 +1357,29 @@ const helpers = {
     return schema.tables.find((table) => table.name === tableName);
   },
   hasColumn(table, columnName) {
-    return table.columns.findIndex((column) => column.name === columnName) !== -1;
+    return (
+      table.columns.findIndex((column) => column.name === columnName) !== -1
+    );
   },
   findColumn(table, columnName) {
     return table.columns.find((column) => column.name === columnName);
   },
   hasIndex(table, columnName) {
-    return table.indexes.findIndex((column) => column.name === columnName) !== -1;
+    return (
+      table.indexes.findIndex((column) => column.name === columnName) !== -1
+    );
   },
   findIndex(table, columnName) {
     return table.indexes.find((column) => column.name === columnName);
   },
   hasForeignKey(table, columnName) {
-    return table.foreignKeys.findIndex((column) => column.name === columnName) !== -1;
+    return (
+      table.foreignKeys.findIndex((column) => column.name === columnName) !== -1
+    );
   },
   findForeignKey(table, columnName) {
     return table.foreignKeys.find((column) => column.name === columnName);
-  }
+  },
 };
 const createSchemaDiff = (db) => {
   const hasChangedStatus = (diff) => diff.status === statuses.CHANGED;
@@ -1306,57 +1388,99 @@ const createSchemaDiff = (db) => {
     if (!___default.default.isEqual(oldIndex.columns, index2.columns)) {
       changes.push("columns");
     }
-    if (oldIndex.type && index2.type && ___default.default.toLower(oldIndex.type) !== ___default.default.toLower(index2.type)) {
+    if (
+      oldIndex.type &&
+      index2.type &&
+      ___default.default.toLower(oldIndex.type) !==
+        ___default.default.toLower(index2.type)
+    ) {
       changes.push("type");
     }
     return {
       status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,
       diff: {
         name: index2.name,
-        object: index2
-      }
+        object: index2,
+      },
     };
   };
   const diffForeignKeys = (oldForeignKey, foreignKey) => {
     const changes = [];
-    if (___default.default.difference(oldForeignKey.columns, foreignKey.columns).length > 0) {
+    if (
+      ___default.default.difference(oldForeignKey.columns, foreignKey.columns)
+        .length > 0
+    ) {
       changes.push("columns");
     }
-    if (___default.default.difference(oldForeignKey.referencedColumns, foreignKey.referencedColumns).length > 0) {
+    if (
+      ___default.default.difference(
+        oldForeignKey.referencedColumns,
+        foreignKey.referencedColumns
+      ).length > 0
+    ) {
       changes.push("referencedColumns");
     }
     if (oldForeignKey.referencedTable !== foreignKey.referencedTable) {
       changes.push("referencedTable");
     }
-    if (___default.default.isNil(oldForeignKey.onDelete) || ___default.default.toUpper(oldForeignKey.onDelete) === "NO ACTION") {
-      if (!___default.default.isNil(foreignKey.onDelete) && ___default.default.toUpper(oldForeignKey.onDelete ?? "") !== "NO ACTION") {
+    if (
+      ___default.default.isNil(oldForeignKey.onDelete) ||
+      ___default.default.toUpper(oldForeignKey.onDelete) === "NO ACTION"
+    ) {
+      if (
+        !___default.default.isNil(foreignKey.onDelete) &&
+        ___default.default.toUpper(oldForeignKey.onDelete ?? "") !== "NO ACTION"
+      ) {
         changes.push("onDelete");
       }
-    } else if (___default.default.toUpper(oldForeignKey.onDelete) !== ___default.default.toUpper(foreignKey.onDelete ?? "")) {
+    } else if (
+      ___default.default.toUpper(oldForeignKey.onDelete) !==
+      ___default.default.toUpper(foreignKey.onDelete ?? "")
+    ) {
       changes.push("onDelete");
     }
-    if (___default.default.isNil(oldForeignKey.onUpdate) || ___default.default.toUpper(oldForeignKey.onUpdate) === "NO ACTION") {
-      if (!___default.default.isNil(foreignKey.onUpdate) && ___default.default.toUpper(oldForeignKey.onUpdate ?? "") !== "NO ACTION") {
+    if (
+      ___default.default.isNil(oldForeignKey.onUpdate) ||
+      ___default.default.toUpper(oldForeignKey.onUpdate) === "NO ACTION"
+    ) {
+      if (
+        !___default.default.isNil(foreignKey.onUpdate) &&
+        ___default.default.toUpper(oldForeignKey.onUpdate ?? "") !== "NO ACTION"
+      ) {
         changes.push("onUpdate");
       }
-    } else if (___default.default.toUpper(oldForeignKey.onUpdate) !== ___default.default.toUpper(foreignKey.onUpdate ?? "")) {
+    } else if (
+      ___default.default.toUpper(oldForeignKey.onUpdate) !==
+      ___default.default.toUpper(foreignKey.onUpdate ?? "")
+    ) {
       changes.push("onUpdate");
     }
     return {
       status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,
       diff: {
         name: foreignKey.name,
-        object: foreignKey
-      }
+        object: foreignKey,
+      },
     };
   };
   const diffDefault = (oldColumn, column) => {
     const oldDefaultTo = oldColumn.defaultTo;
     const { defaultTo } = column;
-    if (oldDefaultTo === null || ___default.default.toLower(oldDefaultTo) === "null") {
-      return ___default.default.isNil(defaultTo) || ___default.default.toLower(defaultTo) === "null";
+    if (
+      oldDefaultTo === null ||
+      ___default.default.toLower(oldDefaultTo) === "null"
+    ) {
+      return (
+        ___default.default.isNil(defaultTo) ||
+        ___default.default.toLower(defaultTo) === "null"
+      );
     }
-    return ___default.default.toLower(oldDefaultTo) === ___default.default.toLower(column.defaultTo) || ___default.default.toLower(oldDefaultTo) === ___default.default.toLower(`'${column.defaultTo}'`);
+    return (
+      ___default.default.toLower(oldDefaultTo) ===
+        ___default.default.toLower(column.defaultTo) ||
+      ___default.default.toLower(oldDefaultTo) ===
+        ___default.default.toLower(`'${column.defaultTo}'`)
+    );
   };
   const diffColumns = (oldColumn, column) => {
     const changes = [];
@@ -1373,15 +1497,18 @@ const createSchemaDiff = (db) => {
     if (!hasSameDefault) {
       changes.push("defaultTo");
     }
-    if (oldColumn.unsigned !== column.unsigned && db.dialect.supportsUnsigned()) {
+    if (
+      oldColumn.unsigned !== column.unsigned &&
+      db.dialect.supportsUnsigned()
+    ) {
       changes.push("unsigned");
     }
     return {
       status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,
       diff: {
         name: column.name,
-        object: column
-      }
+        object: column,
+      },
     };
   };
   const diffTableColumns = (srcTable, destTable) => {
@@ -1407,15 +1534,17 @@ const createSchemaDiff = (db) => {
         removedColumns.push(srcColumn);
       }
     }
-    const hasChanged = [addedColumns, updatedColumns, removedColumns].some((arr) => arr.length > 0);
+    const hasChanged = [addedColumns, updatedColumns, removedColumns].some(
+      (arr) => arr.length > 0
+    );
     return {
       status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,
       diff: {
         added: addedColumns,
         updated: updatedColumns,
         unchanged: unchangedColumns,
-        removed: removedColumns
-      }
+        removed: removedColumns,
+      },
     };
   };
   const diffTableIndexes = (srcTable, destTable) => {
@@ -1441,15 +1570,17 @@ const createSchemaDiff = (db) => {
         removedIndexes.push(srcIndex);
       }
     }
-    const hasChanged = [addedIndexes, updatedIndexes, removedIndexes].some((arr) => arr.length > 0);
+    const hasChanged = [addedIndexes, updatedIndexes, removedIndexes].some(
+      (arr) => arr.length > 0
+    );
     return {
       status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,
       diff: {
         added: addedIndexes,
         updated: updatedIndexes,
         unchanged: unchangedIndexes,
-        removed: removedIndexes
-      }
+        removed: removedIndexes,
+      },
     };
   };
   const diffTableForeignKeys = (srcTable, destTable) => {
@@ -1464,12 +1595,15 @@ const createSchemaDiff = (db) => {
           added: addedForeignKeys,
           updated: updatedForeignKeys,
           unchanged: unchangedForeignKeys,
-          removed: removedForeignKeys
-        }
+          removed: removedForeignKeys,
+        },
       };
     }
     for (const destForeignKey of destTable.foreignKeys) {
-      const srcForeignKey = helpers.findForeignKey(srcTable, destForeignKey.name);
+      const srcForeignKey = helpers.findForeignKey(
+        srcTable,
+        destForeignKey.name
+      );
       if (srcForeignKey) {
         const { status, diff } = diffForeignKeys(srcForeignKey, destForeignKey);
         if (status === statuses.CHANGED) {
@@ -1486,32 +1620,36 @@ const createSchemaDiff = (db) => {
         removedForeignKeys.push(srcForeignKey);
       }
     }
-    const hasChanged = [addedForeignKeys, updatedForeignKeys, removedForeignKeys].some(
-      (arr) => arr.length > 0
-    );
+    const hasChanged = [
+      addedForeignKeys,
+      updatedForeignKeys,
+      removedForeignKeys,
+    ].some((arr) => arr.length > 0);
     return {
       status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,
       diff: {
         added: addedForeignKeys,
         updated: updatedForeignKeys,
         unchanged: unchangedForeignKeys,
-        removed: removedForeignKeys
-      }
+        removed: removedForeignKeys,
+      },
     };
   };
   const diffTables = (srcTable, destTable) => {
     const columnsDiff = diffTableColumns(srcTable, destTable);
     const indexesDiff = diffTableIndexes(srcTable, destTable);
     const foreignKeysDiff = diffTableForeignKeys(srcTable, destTable);
-    const hasChanged = [columnsDiff, indexesDiff, foreignKeysDiff].some(hasChangedStatus);
+    const hasChanged = [columnsDiff, indexesDiff, foreignKeysDiff].some(
+      hasChangedStatus
+    );
     return {
       status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,
       diff: {
         name: srcTable.name,
         indexes: indexesDiff.diff,
         foreignKeys: foreignKeysDiff.diff,
-        columns: columnsDiff.diff
-      }
+        columns: columnsDiff.diff,
+      },
     };
   };
   const diffSchemas = async (srcSchema, destSchema) => {
@@ -1538,26 +1676,44 @@ const createSchemaDiff = (db) => {
       }
       return persistedTable.name;
     };
-    const persistedTables = helpers.hasTable(srcSchema, "strapi_core_store_settings") ? await strapi.store.get({
-      type: "core",
-      key: "persisted_tables"
-    }) ?? [] : [];
-    const reservedTables = [...RESERVED_TABLE_NAMES, ...persistedTables.map(parsePersistedTable)];
+    const persistedTables = helpers.hasTable(
+      srcSchema,
+      "strapi_core_store_settings"
+    )
+      ? (await strapi.store.get({
+          type: "core",
+          key: "persisted_tables",
+        })) ?? []
+      : [];
+    const reservedTables = [
+      ...RESERVED_TABLE_NAMES,
+      ...persistedTables.map(parsePersistedTable),
+    ];
     for (const srcTable of srcSchema.tables) {
-      if (!helpers.hasTable(destSchema, srcTable.name) && !reservedTables.includes(srcTable.name)) {
-        const dependencies = persistedTables.filter((table) => {
-          const dependsOn = table?.dependsOn;
-          if (!___default.default.isArray(dependsOn)) {
-            return;
-          }
-          return dependsOn.some((table2) => table2.name === srcTable.name);
-        }).map((dependsOnTable) => {
-          return srcSchema.tables.find((srcTable2) => srcTable2.name === dependsOnTable.name);
-        }).filter((table) => !___default.default.isNil(table));
+      if (
+        !helpers.hasTable(destSchema, srcTable.name) &&
+        !reservedTables.includes(srcTable.name)
+      ) {
+        const dependencies = persistedTables
+          .filter((table) => {
+            const dependsOn = table?.dependsOn;
+            if (!___default.default.isArray(dependsOn)) {
+              return;
+            }
+            return dependsOn.some((table2) => table2.name === srcTable.name);
+          })
+          .map((dependsOnTable) => {
+            return srcSchema.tables.find(
+              (srcTable2) => srcTable2.name === dependsOnTable.name
+            );
+          })
+          .filter((table) => !___default.default.isNil(table));
         removedTables.push(srcTable, ...dependencies);
       }
     }
-    const hasChanged = [addedTables, updatedTables, removedTables].some((arr) => arr.length > 0);
+    const hasChanged = [addedTables, updatedTables, removedTables].some(
+      (arr) => arr.length > 0
+    );
     return {
       status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,
       diff: {
@@ -1565,13 +1721,13 @@ const createSchemaDiff = (db) => {
           added: addedTables,
           updated: updatedTables,
           unchanged: unchangedTables,
-          removed: removedTables
-        }
-      }
+          removed: removedTables,
+        },
+      },
     };
   };
   return {
-    diff: diffSchemas
+    diff: diffSchemas,
   };
 };
 const TABLE_NAME = "strapi_database_schema";
@@ -1586,40 +1742,52 @@ const createSchemaStorage = (db) => {
     });
   };
   const checkTableExists = async () => {
-    if (!await hasSchemaTable()) {
+    if (!(await hasSchemaTable())) {
       await createSchemaTable();
     }
   };
   return {
     async read() {
       await checkTableExists();
-      const res = await db.getConnection().select("*").from(TABLE_NAME).orderBy("time", "DESC").first();
+      const res = await db
+        .getConnection()
+        .select("*")
+        .from(TABLE_NAME)
+        .orderBy("time", "DESC")
+        .first();
       if (!res) {
         return null;
       }
-      const parsedSchema = typeof res.schema === "object" ? res.schema : JSON.parse(res.schema);
+      const parsedSchema =
+        typeof res.schema === "object" ? res.schema : JSON.parse(res.schema);
       return {
         ...res,
-        schema: parsedSchema
+        schema: parsedSchema,
       };
     },
     hashSchema(schema) {
-      return crypto__default.default.createHash("md5").update(JSON.stringify(schema)).digest("hex");
+      return crypto__default.default
+        .createHash("md5")
+        .update(JSON.stringify(schema))
+        .digest("hex");
     },
     async add(schema) {
       await checkTableExists();
       await db.getConnection(TABLE_NAME).delete();
       const time = /* @__PURE__ */ new Date();
-      await db.getConnection().insert({
-        schema: JSON.stringify(schema),
-        hash: this.hashSchema(schema),
-        time
-      }).into(TABLE_NAME);
+      await db
+        .getConnection()
+        .insert({
+          schema: JSON.stringify(schema),
+          hash: this.hashSchema(schema),
+          time,
+        })
+        .into(TABLE_NAME);
     },
     async clear() {
       await checkTableExists();
       await db.getConnection(TABLE_NAME).truncate();
-    }
+    },
   };
 };
 const SCALAR_TYPES = [
@@ -1641,9 +1809,16 @@ const SCALAR_TYPES = [
   "datetime",
   "timestamp",
   "boolean",
-  "blocks"
+  "blocks",
+];
+const STRING_TYPES = [
+  "string",
+  "text",
+  "uid",
+  "email",
+  "enumeration",
+  "richtext",
 ];
-const STRING_TYPES = ["string", "text", "uid", "email", "enumeration", "richtext"];
 const NUMBER_TYPES = ["biginteger", "integer", "decimal", "float"];
 const isString = (type) => STRING_TYPES.includes(type);
 const isNumber = (type) => NUMBER_TYPES.includes(type);
@@ -1663,7 +1838,7 @@ const createColumn = (name, attribute) => {
     notNullable: false,
     unsigned: false,
     ...opts,
-    ..."column" in attribute ? attribute.column ?? {} : {}
+    ...("column" in attribute ? attribute.column ?? {} : {}),
   };
 };
 const createTable = (meta) => {
@@ -1671,29 +1846,42 @@ const createTable = (meta) => {
     name: meta.tableName,
     indexes: meta.indexes || [],
     foreignKeys: meta.foreignKeys || [],
-    columns: []
+    columns: [],
   };
   for (const key of Object.keys(meta.attributes)) {
     const attribute = meta.attributes[key];
     if (attribute.type === "relation") {
-      if ("morphColumn" in attribute && attribute.morphColumn && attribute.owner) {
+      if (
+        "morphColumn" in attribute &&
+        attribute.morphColumn &&
+        attribute.owner
+      ) {
         const { idColumn, typeColumn } = attribute.morphColumn;
         table.columns.push(
           createColumn(idColumn.name, {
             type: "integer",
             column: {
-              unsigned: true
-            }
+              unsigned: true,
+            },
           })
         );
         table.columns.push(createColumn(typeColumn.name, { type: "string" }));
-      } else if ("joinColumn" in attribute && attribute.joinColumn && attribute.owner && attribute.joinColumn.referencedTable) {
-        const { name: columnName, referencedColumn, referencedTable } = attribute.joinColumn;
+      } else if (
+        "joinColumn" in attribute &&
+        attribute.joinColumn &&
+        attribute.owner &&
+        attribute.joinColumn.referencedTable
+      ) {
+        const {
+          name: columnName,
+          referencedColumn,
+          referencedTable,
+        } = attribute.joinColumn;
         const column = createColumn(columnName, {
           type: "integer",
           column: {
-            unsigned: true
-          }
+            unsigned: true,
+          },
         });
         table.columns.push(column);
         table.foreignKeys.push({
@@ -1702,11 +1890,11 @@ const createTable = (meta) => {
           referencedTable,
           referencedColumns: [referencedColumn],
           // NOTE: could allow configuration
-          onDelete: "SET NULL"
+          onDelete: "SET NULL",
         });
         table.indexes.push({
           name: `${table.name}_${columnName}_fk`,
-          columns: [columnName]
+          columns: [columnName],
         });
       }
     } else if (isScalarAttribute(attribute)) {
@@ -1715,14 +1903,14 @@ const createTable = (meta) => {
         table.indexes.push({
           type: "unique",
           name: `${table.name}_${column.name}_unique`,
-          columns: [column.name]
+          columns: [column.name],
         });
       }
       if (column.primary) {
         table.indexes.push({
           type: "primary",
           name: `${table.name}_${column.name}_primary`,
-          columns: [column.name]
+          columns: [column.name],
         });
       }
       table.columns.push(column);
@@ -1739,7 +1927,7 @@ const getColumnType = (attribute) => {
       return {
         type: "increments",
         args: [{ primary: true, primaryKey: true }],
-        notNullable: true
+        notNullable: true,
       };
     }
     case "password":
@@ -1751,14 +1939,14 @@ const getColumnType = (attribute) => {
     case "uid": {
       return {
         type: "string",
-        unique: true
+        unique: true,
       };
     }
     case "richtext":
     case "text": {
       return {
         type: "text",
-        args: ["longtext"]
+        args: ["longtext"],
       };
     }
     case "blocks":
@@ -1789,9 +1977,9 @@ const getColumnType = (attribute) => {
         args: [
           {
             useTz: false,
-            precision: 6
-          }
-        ]
+            precision: 6,
+          },
+        ],
       };
     }
     case "timestamp": {
@@ -1800,9 +1988,9 @@ const getColumnType = (attribute) => {
         args: [
           {
             useTz: false,
-            precision: 6
-          }
-        ]
+            precision: 6,
+          },
+        ],
       };
     }
     case "boolean": {
@@ -1815,7 +2003,7 @@ const getColumnType = (attribute) => {
 };
 const metadataToSchema = (metadata) => {
   const schema = {
-    tables: []
+    tables: [],
   };
   metadata.forEach((metadata2) => {
     schema.tables.push(createTable(metadata2));
@@ -1882,35 +2070,47 @@ const createSchemaProvider = (db) => {
         return this.syncSchema();
       }
       debug("Schema unchanged");
-    }
+    },
   };
 };
 const hasInversedBy = (attr) => "inversedBy" in attr;
 const hasMappedBy = (attr) => "mappedBy" in attr;
-const isPolymorphic = (attribute) => ["morphOne", "morphMany", "morphToOne", "morphToMany"].includes(attribute.relation);
-const isOneToAny = (attribute) => ["oneToOne", "oneToMany"].includes(attribute.relation);
-const isManyToAny = (attribute) => ["manyToMany", "manyToOne"].includes(attribute.relation);
-const isAnyToOne = (attribute) => ["oneToOne", "manyToOne"].includes(attribute.relation);
-const isAnyToMany = (attribute) => ["oneToMany", "manyToMany"].includes(attribute.relation);
-const isBidirectional = (attribute) => hasInversedBy(attribute) || hasMappedBy(attribute);
-const isOwner = (attribute) => !isBidirectional(attribute) || hasInversedBy(attribute);
-const shouldUseJoinTable = (attribute) => !("useJoinTable" in attribute) || attribute.useJoinTable !== false;
-const getJoinTableName = (tableName, attributeName) => ___default.default.snakeCase(`${tableName}_${attributeName}_links`);
+const isPolymorphic = (attribute) =>
+  ["morphOne", "morphMany", "morphToOne", "morphToMany"].includes(
+    attribute.relation
+  );
+const isOneToAny = (attribute) =>
+  ["oneToOne", "oneToMany"].includes(attribute.relation);
+const isManyToAny = (attribute) =>
+  ["manyToMany", "manyToOne"].includes(attribute.relation);
+const isAnyToOne = (attribute) =>
+  ["oneToOne", "manyToOne"].includes(attribute.relation);
+const isAnyToMany = (attribute) =>
+  ["oneToMany", "manyToMany"].includes(attribute.relation);
+const isBidirectional = (attribute) =>
+  hasInversedBy(attribute) || hasMappedBy(attribute);
+const isOwner = (attribute) =>
+  !isBidirectional(attribute) || hasInversedBy(attribute);
+const shouldUseJoinTable = (attribute) =>
+  !("useJoinTable" in attribute) || attribute.useJoinTable !== false;
+const getJoinTableName = (tableName, attributeName) =>
+  ___default.default.snakeCase(`${tableName}_${attributeName}_links`);
 const hasOrderColumn = (attribute) => isAnyToMany(attribute);
-const hasInverseOrderColumn = (attribute) => isBidirectional(attribute) && isManyToAny(attribute);
+const hasInverseOrderColumn = (attribute) =>
+  isBidirectional(attribute) && isManyToAny(attribute);
 const createOneToOne = (attributeName, attribute, meta, metadata) => {
   if (isOwner(attribute)) {
     if (shouldUseJoinTable(attribute)) {
       createJoinTable(metadata, {
         attribute,
         attributeName,
-        meta
+        meta,
       });
     } else {
       createJoinColum(metadata, {
         attribute,
         attributeName,
-        meta
+        meta,
       });
     }
   }
@@ -1920,10 +2120,12 @@ const createOneToMany = (attributeName, attribute, meta, metadata) => {
     createJoinTable(metadata, {
       attribute,
       attributeName,
-      meta
+      meta,
     });
   } else if (isOwner(attribute)) {
-    throw new Error("one side of a oneToMany cannot be the owner side in a bidirectional relation");
+    throw new Error(
+      "one side of a oneToMany cannot be the owner side in a bidirectional relation"
+    );
   }
 };
 const createManyToOne = (attributeName, attribute, meta, metadata) => {
@@ -1934,13 +2136,13 @@ const createManyToOne = (attributeName, attribute, meta, metadata) => {
     createJoinTable(metadata, {
       attribute,
       attributeName,
-      meta
+      meta,
     });
   } else {
     createJoinColum(metadata, {
       attribute,
       attributeName,
-      meta
+      meta,
     });
   }
 };
@@ -1949,7 +2151,7 @@ const createManyToMany = (attributeName, attribute, meta, metadata) => {
     createJoinTable(metadata, {
       attribute,
       attributeName,
-      meta
+      meta,
     });
   }
 };
@@ -1960,18 +2162,22 @@ const createMorphToOne = (attributeName, attribute) => {
     owner: true,
     morphColumn: attribute.morphColumn ?? {
       typeColumn: {
-        name: typeColumnName
+        name: typeColumnName,
       },
       idColumn: {
         name: idColumnName,
-        referencedColumn: "id"
-      }
-    }
+        referencedColumn: "id",
+      },
+    },
   });
 };
 const createMorphToMany = (attributeName, attribute, meta, metadata) => {
-  const joinTableName = ___default.default.snakeCase(`${meta.tableName}_${attributeName}_morphs`);
-  const joinColumnName = ___default.default.snakeCase(`${meta.singularName}_id`);
+  const joinTableName = ___default.default.snakeCase(
+    `${meta.tableName}_${attributeName}_morphs`
+  );
+  const joinColumnName = ___default.default.snakeCase(
+    `${meta.singularName}_id`
+  );
   const morphColumnName = ___default.default.snakeCase(`${attributeName}`);
   const idColumnName = `${morphColumnName}_id`;
   const typeColumnName = `${morphColumnName}_type`;
@@ -1981,46 +2187,46 @@ const createMorphToMany = (attributeName, attribute, meta, metadata) => {
     tableName: joinTableName,
     attributes: {
       id: {
-        type: "increments"
+        type: "increments",
       },
       [joinColumnName]: {
         type: "integer",
         column: {
-          unsigned: true
-        }
+          unsigned: true,
+        },
       },
       [idColumnName]: {
         type: "integer",
         column: {
-          unsigned: true
-        }
+          unsigned: true,
+        },
       },
       [typeColumnName]: {
-        type: "string"
+        type: "string",
       },
       field: {
-        type: "string"
+        type: "string",
       },
       order: {
         type: "float",
         column: {
-          unsigned: true
-        }
-      }
+          unsigned: true,
+        },
+      },
     },
     indexes: [
       {
         name: `${joinTableName}_fk`,
-        columns: [joinColumnName]
+        columns: [joinColumnName],
       },
       {
         name: `${joinTableName}_order_index`,
-        columns: ["order"]
+        columns: ["order"],
       },
       {
         name: `${joinTableName}_id_column_index`,
-        columns: [idColumnName]
-      }
+        columns: [idColumnName],
+      },
     ],
     foreignKeys: [
       {
@@ -2028,31 +2234,31 @@ const createMorphToMany = (attributeName, attribute, meta, metadata) => {
         columns: [joinColumnName],
         referencedColumns: ["id"],
         referencedTable: meta.tableName,
-        onDelete: "CASCADE"
-      }
+        onDelete: "CASCADE",
+      },
     ],
     lifecycles: {},
-    columnToAttribute: {}
+    columnToAttribute: {},
   });
   const joinTable = {
     name: joinTableName,
     joinColumn: {
       name: joinColumnName,
-      referencedColumn: "id"
+      referencedColumn: "id",
     },
     morphColumn: {
       typeColumn: {
-        name: typeColumnName
+        name: typeColumnName,
       },
       idColumn: {
         name: idColumnName,
-        referencedColumn: "id"
-      }
+        referencedColumn: "id",
+      },
     },
     orderBy: {
-      order: "asc"
+      order: "asc",
     },
-    pivotColumns: [joinColumnName, typeColumnName, idColumnName]
+    pivotColumns: [joinColumnName, typeColumnName, idColumnName],
   };
   attribute.joinTable = joinTable;
 };
@@ -2061,8 +2267,13 @@ const createMorphOne = (attributeName, attribute, meta, metadata) => {
   if (!targetMeta) {
     throw new Error(`Morph target not found. Looking for ${attribute.target}`);
   }
-  if (attribute.morphBy && !___default.default.has(attribute.morphBy, targetMeta.attributes)) {
-    throw new Error(`Morph target attribute not found. Looking for ${attribute.morphBy}`);
+  if (
+    attribute.morphBy &&
+    !___default.default.has(attribute.morphBy, targetMeta.attributes)
+  ) {
+    throw new Error(
+      `Morph target attribute not found. Looking for ${attribute.morphBy}`
+    );
   }
 };
 const createMorphMany = (attributeName, attribute, meta, metadata) => {
@@ -2070,8 +2281,13 @@ const createMorphMany = (attributeName, attribute, meta, metadata) => {
   if (!targetMeta) {
     throw new Error(`Morph target not found. Looking for ${attribute.target}`);
   }
-  if (attribute.morphBy && !___default.default.has(attribute.morphBy, targetMeta.attributes)) {
-    throw new Error(`Morph target attribute not found. Looking for ${attribute.morphBy}`);
+  if (
+    attribute.morphBy &&
+    !___default.default.has(attribute.morphBy, targetMeta.attributes)
+  ) {
+    throw new Error(
+      `Morph target attribute not found. Looking for ${attribute.morphBy}`
+    );
   }
 };
 const createJoinColum = (metadata, { attribute, attributeName }) => {
@@ -2083,7 +2299,7 @@ const createJoinColum = (metadata, { attribute, attributeName }) => {
   const joinColumn = {
     name: joinColumnName,
     referencedColumn: "id",
-    referencedTable: targetMeta.tableName
+    referencedTable: targetMeta.tableName,
   };
   Object.assign(attribute, { owner: true, joinColumn });
   if (isBidirectional(attribute)) {
@@ -2091,8 +2307,8 @@ const createJoinColum = (metadata, { attribute, attributeName }) => {
     Object.assign(inverseAttribute, {
       joinColumn: {
         name: joinColumn.referencedColumn,
-        referencedColumn: joinColumn.name
-      }
+        referencedColumn: joinColumn.name,
+      },
     });
   }
 };
@@ -2102,14 +2318,25 @@ const createJoinTable = (metadata, { attributeName, attribute, meta }) => {
     throw new Error(`Unknown target ${attribute.target}`);
   }
   const joinTableName = getJoinTableName(meta.tableName, attributeName);
-  const joinColumnName = ___default.default.snakeCase(`${meta.singularName}_id`);
-  let inverseJoinColumnName = ___default.default.snakeCase(`${targetMeta.singularName}_id`);
+  const joinColumnName = ___default.default.snakeCase(
+    `${meta.singularName}_id`
+  );
+  let inverseJoinColumnName = ___default.default.snakeCase(
+    `${targetMeta.singularName}_id`
+  );
   if (joinColumnName === inverseJoinColumnName) {
     inverseJoinColumnName = `inv_${inverseJoinColumnName}`;
   }
-  const orderColumnName = ___default.default.snakeCase(`${targetMeta.singularName}_order`);
-  let inverseOrderColumnName = ___default.default.snakeCase(`${meta.singularName}_order`);
-  if (attribute.relation === "manyToMany" && orderColumnName === inverseOrderColumnName) {
+  const orderColumnName = ___default.default.snakeCase(
+    `${targetMeta.singularName}_order`
+  );
+  let inverseOrderColumnName = ___default.default.snakeCase(
+    `${meta.singularName}_order`
+  );
+  if (
+    attribute.relation === "manyToMany" &&
+    orderColumnName === inverseOrderColumnName
+  ) {
     inverseOrderColumnName = `inv_${inverseOrderColumnName}`;
   }
   const metadataSchema = {
@@ -2118,36 +2345,36 @@ const createJoinTable = (metadata, { attributeName, attribute, meta }) => {
     tableName: joinTableName,
     attributes: {
       id: {
-        type: "increments"
+        type: "increments",
       },
       [joinColumnName]: {
         type: "integer",
         column: {
-          unsigned: true
-        }
+          unsigned: true,
+        },
       },
       [inverseJoinColumnName]: {
         type: "integer",
         column: {
-          unsigned: true
-        }
-      }
+          unsigned: true,
+        },
+      },
       // TODO: add extra pivot attributes -> user should use an intermediate entity
     },
     indexes: [
       {
         name: `${joinTableName}_fk`,
-        columns: [joinColumnName]
+        columns: [joinColumnName],
       },
       {
         name: `${joinTableName}_inv_fk`,
-        columns: [inverseJoinColumnName]
+        columns: [inverseJoinColumnName],
       },
       {
         name: `${joinTableName}_unique`,
         columns: [joinColumnName, inverseJoinColumnName],
-        type: "unique"
-      }
+        type: "unique",
+      },
     ],
     foreignKeys: [
       {
@@ -2155,42 +2382,42 @@ const createJoinTable = (metadata, { attributeName, attribute, meta }) => {
         columns: [joinColumnName],
         referencedColumns: ["id"],
         referencedTable: meta.tableName,
-        onDelete: "CASCADE"
+        onDelete: "CASCADE",
       },
       {
         name: `${joinTableName}_inv_fk`,
         columns: [inverseJoinColumnName],
         referencedColumns: ["id"],
         referencedTable: targetMeta.tableName,
-        onDelete: "CASCADE"
-      }
+        onDelete: "CASCADE",
+      },
     ],
     lifecycles: {},
-    columnToAttribute: {}
+    columnToAttribute: {},
   };
   const joinTable = {
     name: joinTableName,
     joinColumn: {
       name: joinColumnName,
-      referencedColumn: "id"
+      referencedColumn: "id",
     },
     inverseJoinColumn: {
       name: inverseJoinColumnName,
-      referencedColumn: "id"
+      referencedColumn: "id",
     },
-    pivotColumns: [joinColumnName, inverseJoinColumnName]
+    pivotColumns: [joinColumnName, inverseJoinColumnName],
   };
   if (isAnyToMany(attribute)) {
     metadataSchema.attributes[orderColumnName] = {
       type: "float",
       column: {
         unsigned: true,
-        defaultTo: null
-      }
+        defaultTo: null,
+      },
     };
     metadataSchema.indexes.push({
       name: `${joinTableName}_order_fk`,
-      columns: [orderColumnName]
+      columns: [orderColumnName],
     });
     joinTable.orderColumnName = orderColumnName;
     joinTable.orderBy = { [orderColumnName]: "asc" };
@@ -2200,19 +2427,21 @@ const createJoinTable = (metadata, { attributeName, attribute, meta }) => {
       type: "float",
       column: {
         unsigned: true,
-        defaultTo: null
-      }
+        defaultTo: null,
+      },
     };
     metadataSchema.indexes.push({
       name: `${joinTableName}_order_inv_fk`,
-      columns: [inverseOrderColumnName]
+      columns: [inverseOrderColumnName],
     });
     joinTable.inverseOrderColumnName = inverseOrderColumnName;
   }
   metadata.add(metadataSchema);
   attribute.joinTable = joinTable;
   if (isBidirectional(attribute)) {
-    const inverseAttribute = attribute.inversedBy ? targetMeta.attributes[attribute.inversedBy] : null;
+    const inverseAttribute = attribute.inversedBy
+      ? targetMeta.attributes[attribute.inversedBy]
+      : null;
     if (!inverseAttribute) {
       throw new Error(
         `inversedBy attribute ${attribute.inversedBy} not found target ${targetMeta.uid}`
@@ -2227,7 +2456,7 @@ const createJoinTable = (metadata, { attributeName, attribute, meta }) => {
       name: joinTableName,
       joinColumn: joinTable.inverseJoinColumn,
       inverseJoinColumn: joinTable.joinColumn,
-      pivotColumns: joinTable.pivotColumns
+      pivotColumns: joinTable.pivotColumns,
     };
     if (isManyToAny(attribute)) {
       inverseAttribute.joinTable.orderColumnName = inverseOrderColumnName;
@@ -2290,20 +2519,22 @@ const createMetadata = (models = []) => {
   const metadata = new Metadata();
   for (const model of ___default.default.cloneDeep(models)) {
     if ("id" in model.attributes) {
-      throw new Error('The attribute "id" is reserved and cannot be used in a model');
+      throw new Error(
+        'The attribute "id" is reserved and cannot be used in a model'
+      );
     }
     metadata.add({
       ...model,
       attributes: {
         id: {
-          type: "increments"
+          type: "increments",
         },
-        ...model.attributes
+        ...model.attributes,
       },
       lifecycles: model.lifecycles ?? {},
       indexes: model.indexes || [],
       foreignKeys: model.foreignKeys || [],
-      columnToAttribute: {}
+      columnToAttribute: {},
     });
   }
   for (const meta of metadata.values()) {
@@ -2338,13 +2569,16 @@ const createMetadata = (models = []) => {
     }
   }
   for (const meta of metadata.values()) {
-    const columnToAttribute = Object.keys(meta.attributes).reduce((acc, key) => {
-      const attribute = meta.attributes[key];
-      if ("columnName" in attribute) {
-        return Object.assign(acc, { [attribute.columnName || key]: key });
-      }
-      return Object.assign(acc, { [key]: key });
-    }, {});
+    const columnToAttribute = Object.keys(meta.attributes).reduce(
+      (acc, key) => {
+        const attribute = meta.attributes[key];
+        if ("columnName" in attribute) {
+          return Object.assign(acc, { [attribute.columnName || key]: key });
+        }
+        return Object.assign(acc, { [key]: key });
+      },
+      {}
+    );
     meta.columnToAttribute = columnToAttribute;
   }
   metadata.validate();
@@ -2364,52 +2598,52 @@ const createCompoLinkModelMeta = (baseModelMeta) => {
     tableName: name,
     attributes: {
       id: {
-        type: "increments"
+        type: "increments",
       },
       entity_id: {
         type: "integer",
         column: {
-          unsigned: true
-        }
+          unsigned: true,
+        },
       },
       component_id: {
         type: "integer",
         column: {
-          unsigned: true
-        }
+          unsigned: true,
+        },
       },
       component_type: {
-        type: "string"
+        type: "string",
       },
       field: {
-        type: "string"
+        type: "string",
       },
       order: {
         type: "float",
         column: {
           unsigned: true,
-          defaultTo: null
-        }
-      }
+          defaultTo: null,
+        },
+      },
     },
     indexes: [
       {
         name: `${baseModelMeta.tableName}_field_index`,
-        columns: ["field"]
+        columns: ["field"],
       },
       {
         name: `${baseModelMeta.tableName}_component_type_index`,
-        columns: ["component_type"]
+        columns: ["component_type"],
       },
       {
         name: `${baseModelMeta.tableName}_entity_fk`,
-        columns: ["entity_id"]
+        columns: ["entity_id"],
       },
       {
         name: `${baseModelMeta.tableName}_unique`,
         columns: ["entity_id", "component_id", "field", "component_type"],
-        type: "unique"
-      }
+        type: "unique",
+      },
     ],
     foreignKeys: [
       {
@@ -2417,11 +2651,11 @@ const createCompoLinkModelMeta = (baseModelMeta) => {
         columns: ["entity_id"],
         referencedColumns: ["id"],
         referencedTable: baseModelMeta.tableName,
-        onDelete: "CASCADE"
-      }
+        onDelete: "CASCADE",
+      },
     ],
     lifecycles: {},
-    columnToAttribute: {}
+    columnToAttribute: {},
   };
 };
 const createDynamicZone = (attributeName, attribute, meta) => {
@@ -2434,52 +2668,55 @@ const createDynamicZone = (attributeName, attribute, meta) => {
       name: meta.componentLink.tableName,
       joinColumn: {
         name: "entity_id",
-        referencedColumn: "id"
+        referencedColumn: "id",
       },
       morphColumn: {
         idColumn: {
           name: "component_id",
-          referencedColumn: "id"
+          referencedColumn: "id",
         },
         typeColumn: {
-          name: "component_type"
+          name: "component_type",
         },
-        typeField: "__component"
+        typeField: "__component",
       },
       on: {
-        field: attributeName
+        field: attributeName,
       },
       orderBy: {
-        order: "asc"
+        order: "asc",
       },
-      pivotColumns: ["entity_id", "component_id", "field", "component_type"]
-    }
+      pivotColumns: ["entity_id", "component_id", "field", "component_type"],
+    },
   });
 };
 const createComponent = (attributeName, attribute, meta) => {
   Object.assign(attribute, {
     type: "relation",
-    relation: "repeatable" in attribute && attribute.repeatable === true ? "oneToMany" : "oneToOne",
+    relation:
+      "repeatable" in attribute && attribute.repeatable === true
+        ? "oneToMany"
+        : "oneToOne",
     target: "component" in attribute && attribute.component,
     joinTable: {
       name: meta.componentLink.tableName,
       joinColumn: {
         name: "entity_id",
-        referencedColumn: "id"
+        referencedColumn: "id",
       },
       inverseJoinColumn: {
         name: "component_id",
-        referencedColumn: "id"
+        referencedColumn: "id",
       },
       on: {
-        field: attributeName
+        field: attributeName,
       },
       orderColumnName: "order",
       orderBy: {
-        order: "asc"
+        order: "asc",
       },
-      pivotColumns: ["entity_id", "component_id", "field", "component_type"]
-    }
+      pivotColumns: ["entity_id", "component_id", "field", "component_type"],
+    },
   });
 };
 const createAttribute = (attributeName, attribute) => {
@@ -2521,8 +2758,7 @@ class JSONField extends Field {
     return value;
   }
 }
-class BigIntegerField extends StringField {
-}
+class BigIntegerField extends StringField {}
 class NumberField extends Field {
   toDB(value) {
     const numberValue = _.toNumber(value);
@@ -2540,7 +2776,8 @@ const isDate = (value) => {
 };
 const DATE_REGEX = /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
 const PARTIAL_DATE_REGEX = /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])/g;
-const TIME_REGEX = /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;
+const TIME_REGEX =
+  /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;
 const parseDateTimeOrTimestamp = (value) => {
   if (isDate(value)) {
     return value;
@@ -2550,13 +2787,21 @@ const parseDateTimeOrTimestamp = (value) => {
     if (dateFns__namespace.isValid(date)) {
       return date;
     }
-    const milliUnixDate = dateFns__namespace.parse(_.toString(value), "T", /* @__PURE__ */ new Date());
+    const milliUnixDate = dateFns__namespace.parse(
+      _.toString(value),
+      "T",
+      /* @__PURE__ */ new Date()
+    );
     if (dateFns__namespace.isValid(milliUnixDate)) {
       return milliUnixDate;
     }
-    throw new InvalidDateTimeError(`Invalid format, expected a timestamp or an ISO date`);
+    throw new InvalidDateTimeError(
+      `Invalid format, expected a timestamp or an ISO date`
+    );
   } catch (error) {
-    throw new InvalidDateTimeError(`Invalid format, expected a timestamp or an ISO date`);
+    throw new InvalidDateTimeError(
+      `Invalid format, expected a timestamp or an ISO date`
+    );
   }
 };
 const parseDate = (value) => {
@@ -2625,7 +2870,9 @@ class TimestampField extends Field {
   }
   fromDB(value) {
     const cast = new Date(value);
-    return dateFns__namespace.isValid(cast) ? dateFns__namespace.format(cast, "T") : null;
+    return dateFns__namespace.isValid(cast)
+      ? dateFns__namespace.format(cast, "T")
+      : null;
   }
 }
 function isStringOrNumber(value) {
@@ -2677,7 +2924,7 @@ const typeToFieldMap = {
   datetime: DatetimeField,
   timestamp: TimestampField,
   boolean: BooleanField,
-  blocks: JSONField
+  blocks: JSONField,
 };
 const createField = (attribute) => {
   const { type } = attribute;
@@ -2725,7 +2972,12 @@ const toSingleRow = (meta, data = {}) => {
   const { attributes } = meta;
   for (const key of Object.keys(data)) {
     const attribute = attributes[key];
-    if (!attribute || !("columnName" in attribute) || !attribute.columnName || attribute.columnName === key) {
+    if (
+      !attribute ||
+      !("columnName" in attribute) ||
+      !attribute.columnName ||
+      attribute.columnName === key
+    ) {
       continue;
     }
     data[attribute.columnName] = data[key];
@@ -2750,7 +3002,7 @@ const toColumnName = (meta, name) => {
   if (!attribute) {
     return name;
   }
-  return "columnName" in attribute && attribute.columnName || name;
+  return ("columnName" in attribute && attribute.columnName) || name;
 };
 const applySearch = (knex2, query, ctx) => {
   const { qb, uid, db } = ctx;
@@ -2759,13 +3011,21 @@ const applySearch = (knex2, query, ctx) => {
   const searchColumns = ["id"];
   const stringColumns = Object.keys(attributes).filter((attributeName) => {
     const attribute = attributes[attributeName];
-    return isScalarAttribute(attribute) && isString(attribute.type) && attribute.searchable !== false;
+    return (
+      isScalarAttribute(attribute) &&
+      isString(attribute.type) &&
+      attribute.searchable !== false
+    );
   });
   searchColumns.push(...stringColumns);
   if (!___default.default.isNaN(___default.default.toNumber(query))) {
     const numberColumns = Object.keys(attributes).filter((attributeName) => {
       const attribute = attributes[attributeName];
-      return isScalarAttribute(attribute) && isNumber(attribute.type) && attribute.searchable !== false;
+      return (
+        isScalarAttribute(attribute) &&
+        isNumber(attribute.type) &&
+        attribute.searchable !== false
+      );
     });
     searchColumns.push(...numberColumns);
   }
@@ -2775,17 +3035,18 @@ const applySearch = (knex2, query, ctx) => {
         const columnName = toColumnName(meta, attr);
         return knex2.orWhereRaw(`??::text ILIKE ?`, [
           qb.aliasColumn(columnName),
-          `%${escapeQuery(query, "*%\\")}%`
+          `%${escapeQuery(query, "*%\\")}%`,
         ]);
       });
       break;
     }
+    case "libsql":
     case "sqlite": {
       searchColumns.forEach((attr) => {
         const columnName = toColumnName(meta, attr);
         return knex2.orWhereRaw(`?? LIKE ? ESCAPE '\\'`, [
           qb.aliasColumn(columnName),
-          `%${escapeQuery(query, "*%\\")}%`
+          `%${escapeQuery(query, "*%\\")}%`,
         ]);
       });
       break;
@@ -2795,7 +3056,7 @@ const applySearch = (knex2, query, ctx) => {
         const columnName = toColumnName(meta, attr);
         return knex2.orWhereRaw(`?? LIKE ?`, [
           qb.aliasColumn(columnName),
-          `%${escapeQuery(query, "*%\\")}%`
+          `%${escapeQuery(query, "*%\\")}%`,
         ]);
       });
       break;
@@ -2803,10 +3064,15 @@ const applySearch = (knex2, query, ctx) => {
   }
 };
 const escapeQuery = (query, charsToEscape, escapeChar = "\\") => {
-  return query.split("").reduce(
-    (escapedQuery, char) => charsToEscape.includes(char) ? `${escapedQuery}${escapeChar}${char}` : `${escapedQuery}${char}`,
-    ""
-  );
+  return query
+    .split("")
+    .reduce(
+      (escapedQuery, char) =>
+        charsToEscape.includes(char)
+          ? `${escapedQuery}${escapeChar}${char}`
+          : `${escapedQuery}${char}`,
+      ""
+    );
 };
 const createPivotJoin = (ctx, { alias, refAlias, joinTable, targetMeta }) => {
   const { qb } = ctx;
@@ -2817,7 +3083,7 @@ const createPivotJoin = (ctx, { alias, refAlias, joinTable, targetMeta }) => {
     referencedColumn: joinTable.joinColumn.name,
     rootColumn: joinTable.joinColumn.referencedColumn,
     rootTable: alias,
-    on: joinTable.on
+    on: joinTable.on,
   });
   const subAlias = refAlias || qb.getAlias();
   qb.join({
@@ -2825,7 +3091,7 @@ const createPivotJoin = (ctx, { alias, refAlias, joinTable, targetMeta }) => {
     referencedTable: targetMeta.tableName,
     referencedColumn: joinTable.inverseJoinColumn.referencedColumn,
     rootColumn: joinTable.inverseJoinColumn.name,
-    rootTable: joinAlias
+    rootTable: joinAlias,
   });
   return subAlias;
 };
@@ -2848,8 +3114,8 @@ const createJoin = (ctx, { alias, refAlias, attributeName, attribute }) => {
         rootTable: alias,
         on: {
           [morphColumn.typeColumn.name]: uid,
-          ...morphColumn.on
-        }
+          ...morphColumn.on,
+        },
       });
       return subAlias;
     }
@@ -2863,8 +3129,8 @@ const createJoin = (ctx, { alias, refAlias, attributeName, attribute }) => {
         rootTable: alias,
         on: {
           [joinTable2.morphColumn.typeColumn.name]: uid,
-          field: attributeName
-        }
+          field: attributeName,
+        },
       });
       const subAlias = refAlias || qb.getAlias();
       qb.join({
@@ -2872,7 +3138,7 @@ const createJoin = (ctx, { alias, refAlias, attributeName, attribute }) => {
         referencedTable: targetMeta.tableName,
         referencedColumn: joinTable2.joinColumn.referencedColumn,
         rootColumn: joinTable2.joinColumn.name,
-        rootTable: joinAlias
+        rootTable: joinAlias,
       });
       return subAlias;
     }
@@ -2886,7 +3152,7 @@ const createJoin = (ctx, { alias, refAlias, attributeName, attribute }) => {
       referencedTable: targetMeta.tableName,
       referencedColumn: joinColumn.referencedColumn,
       rootColumn: joinColumn.name,
-      rootTable: alias
+      rootTable: alias,
     });
     return subAlias;
   }
@@ -2907,7 +3173,7 @@ const applyJoin = (qb, join) => {
     rootTable,
     // = qb.alias
     on,
-    orderBy
+    orderBy,
   } = join;
   qb[method](`${referencedTable} as ${alias}`, (inner) => {
     inner.on(`${rootTable}.${rootColumn}`, `${alias}.${referencedColumn}`);
@@ -2957,13 +3223,13 @@ const processOrderBy = (orderBy, ctx) => {
         const subAlias = createJoin(ctx, {
           alias: alias || qb.alias,
           attributeName: key,
-          attribute
+          attribute,
         });
         return processOrderBy(value, {
           db,
           qb,
           alias: subAlias,
-          uid: attribute.target
+          uid: attribute.target,
         });
       }
       throw new Error(`You cannot order on ${attribute.type} types`);
@@ -2973,13 +3239,23 @@ const processOrderBy = (orderBy, ctx) => {
 };
 const joinColPrefix = "__strapi";
 const XtoOne = async (input, ctx) => {
-  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;
+  const {
+    attribute,
+    attributeName,
+    results,
+    populateValue,
+    targetMeta,
+    isCount,
+  } = input;
   const { db, qb } = ctx;
   const fromTargetRow = (rowOrRows) => fromRow(targetMeta, rowOrRows);
   if ("joinColumn" in attribute && attribute.joinColumn) {
-    const { name: joinColumnName, referencedColumn: referencedColumnName } = attribute.joinColumn;
+    const { name: joinColumnName, referencedColumn: referencedColumnName } =
+      attribute.joinColumn;
     const referencedValues = ___default.default.uniq(
-      results.map((r) => r[joinColumnName]).filter((value) => !___default.default.isNil(value))
+      results
+        .map((r) => r[joinColumnName])
+        .filter((value) => !___default.default.isNil(value))
     );
     if (___default.default.isEmpty(referencedValues)) {
       results.forEach((result) => {
@@ -2987,23 +3263,33 @@ const XtoOne = async (input, ctx) => {
       });
       return;
     }
-    const rows = await db.entityManager.createQueryBuilder(targetMeta.uid).init(populateValue).addSelect(`${qb.alias}.${referencedColumnName}`).where({ [referencedColumnName]: referencedValues }).execute({ mapResults: false });
+    const rows = await db.entityManager
+      .createQueryBuilder(targetMeta.uid)
+      .init(populateValue)
+      .addSelect(`${qb.alias}.${referencedColumnName}`)
+      .where({ [referencedColumnName]: referencedValues })
+      .execute({ mapResults: false });
     const map = ___default.default.groupBy(referencedColumnName)(rows);
     results.forEach((result) => {
-      result[attributeName] = fromTargetRow(___default.default.first(map[result[joinColumnName]]));
+      result[attributeName] = fromTargetRow(
+        ___default.default.first(map[result[joinColumnName]])
+      );
     });
     return;
   }
   if ("joinTable" in attribute && attribute.joinTable) {
     const { joinTable } = attribute;
     const qb2 = db.entityManager.createQueryBuilder(targetMeta.uid);
-    const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;
+    const { name: joinColumnName, referencedColumn: referencedColumnName } =
+      joinTable.joinColumn;
     const alias = qb2.getAlias();
     const joinColAlias = `${alias}.${joinColumnName}`;
     const joinColRenameAs = `${joinColPrefix}${joinColumnName}`;
     const joinColSelect = `${joinColAlias} as ${joinColRenameAs}`;
     const referencedValues = ___default.default.uniq(
-      results.map((r) => r[referencedColumnName]).filter((value) => !___default.default.isNil(value))
+      results
+        .map((r) => r[referencedColumnName])
+        .filter((value) => !___default.default.isNil(value))
     );
     if (isCount) {
       if (___default.default.isEmpty(referencedValues)) {
@@ -3012,20 +3298,28 @@ const XtoOne = async (input, ctx) => {
         });
         return;
       }
-      const rows2 = await qb2.init(populateValue).join({
-        alias,
-        referencedTable: joinTable.name,
-        referencedColumn: joinTable.inverseJoinColumn.name,
-        rootColumn: joinTable.inverseJoinColumn.referencedColumn,
-        rootTable: qb2.alias,
-        on: joinTable.on
-      }).select([joinColAlias, qb2.raw("count(*) AS count")]).where({ [joinColAlias]: referencedValues }).groupBy(joinColAlias).execute({ mapResults: false });
+      const rows2 = await qb2
+        .init(populateValue)
+        .join({
+          alias,
+          referencedTable: joinTable.name,
+          referencedColumn: joinTable.inverseJoinColumn.name,
+          rootColumn: joinTable.inverseJoinColumn.referencedColumn,
+          rootTable: qb2.alias,
+          on: joinTable.on,
+        })
+        .select([joinColAlias, qb2.raw("count(*) AS count")])
+        .where({ [joinColAlias]: referencedValues })
+        .groupBy(joinColAlias)
+        .execute({ mapResults: false });
       const map2 = rows2.reduce((map3, row) => {
         map3[row[joinColumnName]] = { count: Number(row.count) };
         return map3;
       }, {});
       results.forEach((result) => {
-        result[attributeName] = map2[result[referencedColumnName]] || { count: 0 };
+        result[attributeName] = map2[result[referencedColumnName]] || {
+          count: 0,
+        };
       });
       return;
     }
@@ -3035,29 +3329,46 @@ const XtoOne = async (input, ctx) => {
       });
       return;
     }
-    const rows = await qb2.init(populateValue).join({
-      alias,
-      referencedTable: joinTable.name,
-      referencedColumn: joinTable.inverseJoinColumn.name,
-      rootColumn: joinTable.inverseJoinColumn.referencedColumn,
-      rootTable: qb2.alias,
-      on: joinTable.on,
-      orderBy: joinTable.orderBy
-    }).addSelect(joinColSelect).where({ [joinColAlias]: referencedValues }).execute({ mapResults: false });
+    const rows = await qb2
+      .init(populateValue)
+      .join({
+        alias,
+        referencedTable: joinTable.name,
+        referencedColumn: joinTable.inverseJoinColumn.name,
+        rootColumn: joinTable.inverseJoinColumn.referencedColumn,
+        rootTable: qb2.alias,
+        on: joinTable.on,
+        orderBy: joinTable.orderBy,
+      })
+      .addSelect(joinColSelect)
+      .where({ [joinColAlias]: referencedValues })
+      .execute({ mapResults: false });
     const map = ___default.default.groupBy(joinColRenameAs)(rows);
     results.forEach((result) => {
-      result[attributeName] = fromTargetRow(___default.default.first(map[result[referencedColumnName]]));
+      result[attributeName] = fromTargetRow(
+        ___default.default.first(map[result[referencedColumnName]])
+      );
     });
   }
 };
 const oneToMany = async (input, ctx) => {
-  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;
+  const {
+    attribute,
+    attributeName,
+    results,
+    populateValue,
+    targetMeta,
+    isCount,
+  } = input;
   const { db, qb } = ctx;
   const fromTargetRow = (rowOrRows) => fromRow(targetMeta, rowOrRows);
   if ("joinColumn" in attribute && attribute.joinColumn) {
-    const { name: joinColumnName, referencedColumn: referencedColumnName } = attribute.joinColumn;
+    const { name: joinColumnName, referencedColumn: referencedColumnName } =
+      attribute.joinColumn;
     const referencedValues = ___default.default.uniq(
-      results.map((r) => r[joinColumnName]).filter((value) => !___default.default.isNil(value))
+      results
+        .map((r) => r[joinColumnName])
+        .filter((value) => !___default.default.isNil(value))
     );
     if (___default.default.isEmpty(referencedValues)) {
       results.forEach((result) => {
@@ -3065,7 +3376,12 @@ const oneToMany = async (input, ctx) => {
       });
       return;
     }
-    const rows = await db.entityManager.createQueryBuilder(targetMeta.uid).init(populateValue).addSelect(`${qb.alias}.${referencedColumnName}`).where({ [referencedColumnName]: referencedValues }).execute({ mapResults: false });
+    const rows = await db.entityManager
+      .createQueryBuilder(targetMeta.uid)
+      .init(populateValue)
+      .addSelect(`${qb.alias}.${referencedColumnName}`)
+      .where({ [referencedColumnName]: referencedValues })
+      .execute({ mapResults: false });
     const map = ___default.default.groupBy(referencedColumnName)(rows);
     results.forEach((result) => {
       result[attributeName] = fromTargetRow(map[result[joinColumnName]] || []);
@@ -3075,13 +3391,16 @@ const oneToMany = async (input, ctx) => {
   if ("joinTable" in attribute && attribute.joinTable) {
     const { joinTable } = attribute;
     const qb2 = db.entityManager.createQueryBuilder(targetMeta.uid);
-    const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;
+    const { name: joinColumnName, referencedColumn: referencedColumnName } =
+      joinTable.joinColumn;
     const alias = qb2.getAlias();
     const joinColAlias = `${alias}.${joinColumnName}`;
     const joinColRenameAs = `${joinColPrefix}${joinColumnName}`;
     const joinColSelect = `${joinColAlias} as ${joinColRenameAs}`;
     const referencedValues = ___default.default.uniq(
-      results.map((r) => r[referencedColumnName]).filter((value) => !___default.default.isNil(value))
+      results
+        .map((r) => r[referencedColumnName])
+        .filter((value) => !___default.default.isNil(value))
     );
     if (isCount) {
       if (___default.default.isEmpty(referencedValues)) {
@@ -3090,20 +3409,28 @@ const oneToMany = async (input, ctx) => {
         });
         return;
       }
-      const rows2 = await qb2.init(populateValue).join({
-        alias,
-        referencedTable: joinTable.name,
-        referencedColumn: joinTable.inverseJoinColumn.name,
-        rootColumn: joinTable.inverseJoinColumn.referencedColumn,
-        rootTable: qb2.alias,
-        on: joinTable.on
-      }).select([joinColSelect, qb2.raw("count(*) AS count")]).where({ [joinColAlias]: referencedValues }).groupBy(joinColAlias).execute({ mapResults: false });
+      const rows2 = await qb2
+        .init(populateValue)
+        .join({
+          alias,
+          referencedTable: joinTable.name,
+          referencedColumn: joinTable.inverseJoinColumn.name,
+          rootColumn: joinTable.inverseJoinColumn.referencedColumn,
+          rootTable: qb2.alias,
+          on: joinTable.on,
+        })
+        .select([joinColSelect, qb2.raw("count(*) AS count")])
+        .where({ [joinColAlias]: referencedValues })
+        .groupBy(joinColAlias)
+        .execute({ mapResults: false });
       const map2 = rows2.reduce((map3, row) => {
         map3[row[joinColRenameAs]] = { count: Number(row.count) };
         return map3;
       }, {});
       results.forEach((result) => {
-        result[attributeName] = map2[result[referencedColumnName]] || { count: 0 };
+        result[attributeName] = map2[result[referencedColumnName]] || {
+          count: 0,
+        };
       });
       return;
     }
@@ -3113,15 +3440,23 @@ const oneToMany = async (input, ctx) => {
       });
       return;
     }
-    const rows = await qb2.init(populateValue).join({
-      alias,
-      referencedTable: joinTable.name,
-      referencedColumn: joinTable.inverseJoinColumn.name,
-      rootColumn: joinTable.inverseJoinColumn.referencedColumn,
-      rootTable: qb2.alias,
-      on: joinTable.on,
-      orderBy: ___default.default.mapValues((v) => populateValue.ordering || v, joinTable.orderBy)
-    }).addSelect(joinColSelect).where({ [joinColAlias]: referencedValues }).execute({ mapResults: false });
+    const rows = await qb2
+      .init(populateValue)
+      .join({
+        alias,
+        referencedTable: joinTable.name,
+        referencedColumn: joinTable.inverseJoinColumn.name,
+        rootColumn: joinTable.inverseJoinColumn.referencedColumn,
+        rootTable: qb2.alias,
+        on: joinTable.on,
+        orderBy: ___default.default.mapValues(
+          (v) => populateValue.ordering || v,
+          joinTable.orderBy
+        ),
+      })
+      .addSelect(joinColSelect)
+      .where({ [joinColAlias]: referencedValues })
+      .execute({ mapResults: false });
     const map = ___default.default.groupBy(joinColRenameAs)(rows);
     results.forEach((r) => {
       r[attributeName] = fromTargetRow(map[r[referencedColumnName]] || []);
@@ -3129,18 +3464,28 @@ const oneToMany = async (input, ctx) => {
   }
 };
 const manyToMany = async (input, ctx) => {
-  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;
+  const {
+    attribute,
+    attributeName,
+    results,
+    populateValue,
+    targetMeta,
+    isCount,
+  } = input;
   const { db } = ctx;
   const fromTargetRow = (rowOrRows) => fromRow(targetMeta, rowOrRows);
   const { joinTable } = attribute;
   const populateQb = db.entityManager.createQueryBuilder(targetMeta.uid);
-  const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;
+  const { name: joinColumnName, referencedColumn: referencedColumnName } =
+    joinTable.joinColumn;
   const alias = populateQb.getAlias();
   const joinColAlias = `${alias}.${joinColumnName}`;
   const joinColRenameAs = `${joinColPrefix}${joinColumnName}`;
   const joinColSelect = `${joinColAlias} as ${joinColRenameAs}`;
   const referencedValues = ___default.default.uniq(
-    results.map((r) => r[referencedColumnName]).filter((value) => !___default.default.isNil(value))
+    results
+      .map((r) => r[referencedColumnName])
+      .filter((value) => !___default.default.isNil(value))
   );
   if (isCount) {
     if (___default.default.isEmpty(referencedValues)) {
@@ -3149,20 +3494,28 @@ const manyToMany = async (input, ctx) => {
       });
       return;
     }
-    const rows2 = await populateQb.init(populateValue).join({
-      alias,
-      referencedTable: joinTable.name,
-      referencedColumn: joinTable.inverseJoinColumn.name,
-      rootColumn: joinTable.inverseJoinColumn.referencedColumn,
-      rootTable: populateQb.alias,
-      on: joinTable.on
-    }).select([joinColAlias, populateQb.raw("count(*) AS count")]).where({ [joinColAlias]: referencedValues }).groupBy(joinColAlias).execute({ mapResults: false });
+    const rows2 = await populateQb
+      .init(populateValue)
+      .join({
+        alias,
+        referencedTable: joinTable.name,
+        referencedColumn: joinTable.inverseJoinColumn.name,
+        rootColumn: joinTable.inverseJoinColumn.referencedColumn,
+        rootTable: populateQb.alias,
+        on: joinTable.on,
+      })
+      .select([joinColAlias, populateQb.raw("count(*) AS count")])
+      .where({ [joinColAlias]: referencedValues })
+      .groupBy(joinColAlias)
+      .execute({ mapResults: false });
     const map2 = rows2.reduce((map3, row) => {
       map3[row[joinColumnName]] = { count: Number(row.count) };
       return map3;
     }, {});
     results.forEach((result) => {
-      result[attributeName] = map2[result[referencedColumnName]] || { count: 0 };
+      result[attributeName] = map2[result[referencedColumnName]] || {
+        count: 0,
+      };
     });
     return;
   }
@@ -3172,30 +3525,46 @@ const manyToMany = async (input, ctx) => {
     });
     return;
   }
-  const rows = await populateQb.init(populateValue).join({
-    alias,
-    referencedTable: joinTable.name,
-    referencedColumn: joinTable.inverseJoinColumn.name,
-    rootColumn: joinTable.inverseJoinColumn.referencedColumn,
-    rootTable: populateQb.alias,
-    on: joinTable.on,
-    orderBy: ___default.default.mapValues((v) => populateValue.ordering || v, joinTable.orderBy)
-  }).addSelect(joinColSelect).where({ [joinColAlias]: referencedValues }).execute({ mapResults: false });
+  const rows = await populateQb
+    .init(populateValue)
+    .join({
+      alias,
+      referencedTable: joinTable.name,
+      referencedColumn: joinTable.inverseJoinColumn.name,
+      rootColumn: joinTable.inverseJoinColumn.referencedColumn,
+      rootTable: populateQb.alias,
+      on: joinTable.on,
+      orderBy: ___default.default.mapValues(
+        (v) => populateValue.ordering || v,
+        joinTable.orderBy
+      ),
+    })
+    .addSelect(joinColSelect)
+    .where({ [joinColAlias]: referencedValues })
+    .execute({ mapResults: false });
   const map = ___default.default.groupBy(joinColRenameAs)(rows);
   results.forEach((result) => {
-    result[attributeName] = fromTargetRow(map[result[referencedColumnName]] || []);
+    result[attributeName] = fromTargetRow(
+      map[result[referencedColumnName]] || []
+    );
   });
 };
 const morphX = async (input, ctx) => {
-  const { attribute, attributeName, results, populateValue, targetMeta } = input;
+  const { attribute, attributeName, results, populateValue, targetMeta } =
+    input;
   const { db, uid } = ctx;
   const fromTargetRow = (rowOrRows) => fromRow(targetMeta, rowOrRows);
   const { target, morphBy } = attribute;
   const targetAttribute = db.metadata.get(target).attributes[morphBy];
-  if (targetAttribute.type === "relation" && targetAttribute.relation === "morphToOne") {
+  if (
+    targetAttribute.type === "relation" &&
+    targetAttribute.relation === "morphToOne"
+  ) {
     const { idColumn, typeColumn } = targetAttribute.morphColumn;
     const referencedValues = ___default.default.uniq(
-      results.map((r) => r[idColumn.referencedColumn]).filter((value) => !___default.default.isNil(value))
+      results
+        .map((r) => r[idColumn.referencedColumn])
+        .filter((value) => !___default.default.isNil(value))
     );
     if (___default.default.isEmpty(referencedValues)) {
       results.forEach((result) => {
@@ -3203,19 +3572,31 @@ const morphX = async (input, ctx) => {
       });
       return;
     }
-    const rows = await db.entityManager.createQueryBuilder(target).init(populateValue).where({ [idColumn.name]: referencedValues, [typeColumn.name]: uid }).execute({ mapResults: false });
+    const rows = await db.entityManager
+      .createQueryBuilder(target)
+      .init(populateValue)
+      .where({ [idColumn.name]: referencedValues, [typeColumn.name]: uid })
+      .execute({ mapResults: false });
     const map = ___default.default.groupBy(idColumn.name)(rows);
     results.forEach((result) => {
       const matchingRows = map[result[idColumn.referencedColumn]];
-      const matchingValue = attribute.relation === "morphOne" ? ___default.default.first(matchingRows) : matchingRows;
+      const matchingValue =
+        attribute.relation === "morphOne"
+          ? ___default.default.first(matchingRows)
+          : matchingRows;
       result[attributeName] = fromTargetRow(matchingValue);
     });
-  } else if (targetAttribute.type === "relation" && targetAttribute.relation === "morphToMany") {
+  } else if (
+    targetAttribute.type === "relation" &&
+    targetAttribute.relation === "morphToMany"
+  ) {
     const { joinTable } = targetAttribute;
     const { joinColumn, morphColumn } = joinTable;
     const { idColumn, typeColumn } = morphColumn;
     const referencedValues = ___default.default.uniq(
-      results.map((r) => r[idColumn.referencedColumn]).filter((value) => !___default.default.isNil(value))
+      results
+        .map((r) => r[idColumn.referencedColumn])
+        .filter((value) => !___default.default.isNil(value))
     );
     if (___default.default.isEmpty(referencedValues)) {
       results.forEach((result) => {
@@ -3225,25 +3606,36 @@ const morphX = async (input, ctx) => {
     }
     const qb = db.entityManager.createQueryBuilder(target);
     const alias = qb.getAlias();
-    const rows = await qb.init(populateValue).join({
-      alias,
-      referencedTable: joinTable.name,
-      referencedColumn: joinColumn.name,
-      rootColumn: joinColumn.referencedColumn,
-      rootTable: qb.alias,
-      on: {
-        ...joinTable.on || {},
-        field: attributeName
-      },
-      orderBy: ___default.default.mapValues((v) => populateValue.ordering || v, joinTable.orderBy)
-    }).addSelect([`${alias}.${idColumn.name}`, `${alias}.${typeColumn.name}`]).where({
-      [`${alias}.${idColumn.name}`]: referencedValues,
-      [`${alias}.${typeColumn.name}`]: uid
-    }).execute({ mapResults: false });
+    const rows = await qb
+      .init(populateValue)
+      .join({
+        alias,
+        referencedTable: joinTable.name,
+        referencedColumn: joinColumn.name,
+        rootColumn: joinColumn.referencedColumn,
+        rootTable: qb.alias,
+        on: {
+          ...(joinTable.on || {}),
+          field: attributeName,
+        },
+        orderBy: ___default.default.mapValues(
+          (v) => populateValue.ordering || v,
+          joinTable.orderBy
+        ),
+      })
+      .addSelect([`${alias}.${idColumn.name}`, `${alias}.${typeColumn.name}`])
+      .where({
+        [`${alias}.${idColumn.name}`]: referencedValues,
+        [`${alias}.${typeColumn.name}`]: uid,
+      })
+      .execute({ mapResults: false });
     const map = ___default.default.groupBy(idColumn.name)(rows);
     results.forEach((result) => {
       const matchingRows = map[result[idColumn.referencedColumn]];
-      const matchingValue = attribute.relation === "morphOne" ? ___default.default.first(matchingRows) : matchingRows;
+      const matchingValue =
+        attribute.relation === "morphOne"
+          ? ___default.default.first(matchingRows)
+          : matchingRows;
       result[attributeName] = fromTargetRow(matchingValue);
     });
   }
@@ -3255,16 +3647,23 @@ const morphToMany = async (input, ctx) => {
   const { joinColumn, morphColumn } = joinTable;
   const { idColumn, typeColumn, typeField = "__type" } = morphColumn;
   const referencedValues = ___default.default.uniq(
-    results.map((r) => r[joinColumn.referencedColumn]).filter((value) => !___default.default.isNil(value))
+    results
+      .map((r) => r[joinColumn.referencedColumn])
+      .filter((value) => !___default.default.isNil(value))
   );
   const qb = db.entityManager.createQueryBuilder(joinTable.name);
-  const joinRows = await qb.where({
-    [joinColumn.name]: referencedValues,
-    ...joinTable.on || {},
-    // If the populateValue contains an "on" property,
-    // only populate the types defined in it
-    ..."on" in populateValue ? { [morphColumn.typeColumn.name]: Object.keys(populateValue.on ?? {}) } : {}
-  }).orderBy([joinColumn.name, "order"]).execute({ mapResults: false });
+  const joinRows = await qb
+    .where({
+      [joinColumn.name]: referencedValues,
+      ...(joinTable.on || {}),
+      // If the populateValue contains an "on" property,
+      // only populate the types defined in it
+      ...("on" in populateValue
+        ? { [morphColumn.typeColumn.name]: Object.keys(populateValue.on ?? {}) }
+        : {}),
+    })
+    .orderBy([joinColumn.name, "order"])
+    .execute({ mapResults: false });
   const joinMap = ___default.default.groupBy(joinColumn.name, joinRows);
   const idsByType = joinRows.reduce((acc, result) => {
     const idValue = result[morphColumn.idColumn.name];
@@ -3287,7 +3686,11 @@ const morphToMany = async (input, ctx) => {
       continue;
     }
     const qb2 = db.entityManager.createQueryBuilder(type);
-    const rows = await qb2.init(on?.[type] ?? typePopulate).addSelect(`${qb2.alias}.${idColumn.referencedColumn}`).where({ [idColumn.referencedColumn]: ids }).execute({ mapResults: false });
+    const rows = await qb2
+      .init(on?.[type] ?? typePopulate)
+      .addSelect(`${qb2.alias}.${idColumn.referencedColumn}`)
+      .where({ [idColumn.referencedColumn]: ids })
+      .execute({ mapResults: false });
     map[type] = ___default.default.groupBy(idColumn.referencedColumn)(rows);
   }
   results.forEach((result) => {
@@ -3300,7 +3703,7 @@ const morphToMany = async (input, ctx) => {
       return (map[type][id] || []).map((row) => {
         return {
           [typeField]: type,
-          ...fromTargetRow(row)
+          ...fromTargetRow(row),
         };
       });
     });
@@ -3333,7 +3736,11 @@ const morphToOne = async (input, ctx) => {
       return;
     }
     const qb = db.entityManager.createQueryBuilder(type);
-    const rows = await qb.init(on?.[type] ?? typePopulate).addSelect(`${qb.alias}.${idColumn.referencedColumn}`).where({ [idColumn.referencedColumn]: ids }).execute({ mapResults: false });
+    const rows = await qb
+      .init(on?.[type] ?? typePopulate)
+      .addSelect(`${qb.alias}.${idColumn.referencedColumn}`)
+      .where({ [idColumn.referencedColumn]: ids })
+      .execute({ mapResults: false });
     map[type] = ___default.default.groupBy(idColumn.referencedColumn)(rows);
   }
   results.forEach((result) => {
@@ -3344,8 +3751,11 @@ const morphToOne = async (input, ctx) => {
       return;
     }
     const matchingRows = map[type][id];
-    const fromTargetRow = (rowOrRows) => fromRow(db.metadata.get(type), rowOrRows);
-    result[attributeName] = fromTargetRow(___default.default.first(matchingRows));
+    const fromTargetRow = (rowOrRows) =>
+      fromRow(db.metadata.get(type), rowOrRows);
+    result[attributeName] = fromTargetRow(
+      ___default.default.first(matchingRows)
+    );
   });
 };
 const pickPopulateParams = (populate) => {
@@ -3357,7 +3767,7 @@ const pickPopulateParams = (populate) => {
     "orderBy",
     "filters",
     "ordering",
-    "on"
+    "on",
   ];
   if (populate.count !== true) {
     fieldsToPick.push("limit", "offset");
@@ -3377,43 +3787,83 @@ const applyPopulate = async (results, populate, ctx) => {
     }
     const populateValue = {
       filters: qb.state.filters,
-      ...pickPopulateParams(populate[attributeName])
+      ...pickPopulateParams(populate[attributeName]),
     };
     const isCount = "count" in populateValue && populateValue.count === true;
     switch (attribute.relation) {
       case "oneToOne":
       case "manyToOne": {
         const targetMeta = db.metadata.get(attribute.target);
-        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };
+        const input = {
+          attribute,
+          attributeName,
+          results,
+          populateValue,
+          targetMeta,
+          isCount,
+        };
         await XtoOne(input, ctx);
         break;
       }
       case "oneToMany": {
         const targetMeta = db.metadata.get(attribute.target);
-        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };
+        const input = {
+          attribute,
+          attributeName,
+          results,
+          populateValue,
+          targetMeta,
+          isCount,
+        };
         await oneToMany(input, ctx);
         break;
       }
       case "manyToMany": {
         const targetMeta = db.metadata.get(attribute.target);
-        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };
+        const input = {
+          attribute,
+          attributeName,
+          results,
+          populateValue,
+          targetMeta,
+          isCount,
+        };
         await manyToMany(input, ctx);
         break;
       }
       case "morphOne":
       case "morphMany": {
         const targetMeta = db.metadata.get(attribute.target);
-        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };
+        const input = {
+          attribute,
+          attributeName,
+          results,
+          populateValue,
+          targetMeta,
+          isCount,
+        };
         await morphX(input, ctx);
         break;
       }
       case "morphToMany": {
-        const input = { attribute, attributeName, results, populateValue, isCount };
+        const input = {
+          attribute,
+          attributeName,
+          results,
+          populateValue,
+          isCount,
+        };
         await morphToMany(input, ctx);
         break;
       }
       case "morphToOne": {
-        const input = { attribute, attributeName, results, populateValue, isCount };
+        const input = {
+          attribute,
+          attributeName,
+          results,
+          populateValue,
+          isCount,
+        };
         await morphToOne(input, ctx);
         break;
       }
@@ -3448,14 +3898,16 @@ const processPopulate = (populate, ctx) => {
           const populateValue = populateMap[root];
           if (populateValue === true) {
             populateMap[root] = {
-              populate: [subPopulate]
+              populate: [subPopulate],
             };
           } else {
-            populateValue.populate = [subPopulate].concat(populateValue.populate ?? []);
+            populateValue.populate = [subPopulate].concat(
+              populateValue.populate ?? []
+            );
           }
         } else {
           populateMap[root] = {
-            populate: [subPopulate]
+            populate: [subPopulate],
           };
         }
       } else {
@@ -3488,7 +3940,10 @@ const processPopulate = (populate, ctx) => {
   return finalPopulate;
 };
 function isKnexQuery(value) {
-  return value instanceof KnexBuilder__default.default || value instanceof KnexRaw__default.default;
+  return (
+    value instanceof KnexBuilder__default.default ||
+    value instanceof KnexRaw__default.default
+  );
 }
 const addSchema = (db, tableName) => {
   const schemaName = db.getSchemaName();
@@ -3524,7 +3979,9 @@ const processSingleAttributeWhere = (attribute, where, operator = "$eq") => {
 };
 const processAttributeWhere = (attribute, where, operator = "$eq") => {
   if (_.isArray(where)) {
-    return where.map((sub) => processSingleAttributeWhere(attribute, sub, operator));
+    return where.map((sub) =>
+      processSingleAttributeWhere(attribute, sub, operator)
+    );
   }
   return processSingleAttributeWhere(attribute, where, operator);
 };
@@ -3543,7 +4000,9 @@ const processRelationWhere = (where, ctx) => {
   const keys = Object.keys(where);
   const operatorKeys = keys.filter((key) => utils.isOperator(key));
   if (operatorKeys.length > 0 && operatorKeys.length !== keys.length) {
-    throw new Error(`Operator and non-operator keys cannot be mixed in a relation where clause`);
+    throw new Error(
+      `Operator and non-operator keys cannot be mixed in a relation where clause`
+    );
   }
   if (operatorKeys.length > 1) {
     throw new Error(
@@ -3596,13 +4055,13 @@ function processWhere(where, ctx) {
       const subAlias = createJoin(ctx, {
         alias: alias || qb.alias,
         attributeName: key,
-        attribute
+        attribute,
       });
       const nestedWhere = processRelationWhere(value, {
         db,
         qb,
         alias: subAlias,
-        uid: attribute.target
+        uid: attribute.target,
       });
       Object.assign(filters, nestedWhere);
       continue;
@@ -3620,8 +4079,8 @@ function processWhere(where, ctx) {
 const applyOperator = (qb, column, operator, value) => {
   if (Array.isArray(value) && !utils.isOperatorOfType("array", operator)) {
     return qb.where((subQB) => {
-      value.forEach(
-        (subValue) => subQB.orWhere((innerQB) => {
+      value.forEach((subValue) =>
+        subQB.orWhere((innerQB) => {
           applyOperator(innerQB, column, operator, subValue);
         })
       );
@@ -3669,7 +4128,10 @@ const applyOperator = (qb, column, operator, value) => {
         qb.whereNotNull(column);
         break;
       }
-      qb.whereRaw(`${fieldLowerFn(qb)} NOT LIKE LOWER(?)`, [column, `${value}`]);
+      qb.whereRaw(`${fieldLowerFn(qb)} NOT LIKE LOWER(?)`, [
+        column,
+        `${value}`,
+      ]);
       break;
     }
     case "$gt": {
@@ -3737,7 +4199,10 @@ const applyOperator = (qb, column, operator, value) => {
       break;
     }
     case "$notContainsi": {
-      qb.whereRaw(`${fieldLowerFn(qb)} NOT LIKE LOWER(?)`, [column, `%${value}%`]);
+      qb.whereRaw(`${fieldLowerFn(qb)} NOT LIKE LOWER(?)`, [
+        column,
+        `%${value}%`,
+      ]);
       break;
     }
     case "$jsonSupersetOf": {
@@ -3767,8 +4232,8 @@ const applyWhere = (qb, where) => {
     throw new Error("Where must be an array or an object");
   }
   if (_.isArray(where)) {
-    return qb.where(
-      (subQB) => where.forEach((subWhere) => applyWhere(subQB, subWhere))
+    return qb.where((subQB) =>
+      where.forEach((subWhere) => applyWhere(subQB, subWhere))
     );
   }
   Object.keys(where).forEach((key) => {
@@ -3843,22 +4308,18 @@ class ReadableStrapiQuery extends stream.Readable {
   async _read(size) {
     const query = this._query;
     query.clear("limit").clear("offset");
-    const maxReadSize = (
+    const maxReadSize =
       // if no limit is defined in the query, use the given size,
       // otherwise, use the smallest value between the two
-      this._limit === null ? size : Math.min(size, this._limit)
-    );
-    const limit = (
+      this._limit === null ? size : Math.min(size, this._limit);
+    const limit =
       // If a limit is defined
       this._limit !== null && // And reading `maxReadSize` would fetch too many entities (> _limit)
-      this._fetched + maxReadSize > this._limit ? (
-        // Then adjust the limit so that it only get the remaining entities
-        this._limit - this._fetched
-      ) : (
-        // Else, use the max read size
-        maxReadSize
-      )
-    );
+      this._fetched + maxReadSize > this._limit
+        ? // Then adjust the limit so that it only get the remaining entities
+          this._limit - this._fetched
+        : // Else, use the max read size
+          maxReadSize;
     if (limit <= 0) {
       this.push(null);
       return;
@@ -3873,7 +4334,11 @@ class ReadableStrapiQuery extends stream.Readable {
       results = await query;
       const { populate } = this._qb.state;
       if (populate) {
-        await applyPopulate(results, populate, { qb: this._qb, uid: this._uid, db: this._db });
+        await applyPopulate(results, populate, {
+          qb: this._qb,
+          uid: this._uid,
+          db: this._db,
+        });
       }
       if (this._mapResults) {
         results = fromRow(this._meta, results);
@@ -3909,7 +4374,7 @@ const transactionCtx = {
         trx,
         // Fill with existing callbacks if nesting transactions
         commitCallbacks: store?.commitCallbacks || [],
-        rollbackCallbacks: store?.rollbackCallbacks || []
+        rollbackCallbacks: store?.rollbackCallbacks || [],
       },
       cb
     );
@@ -3953,7 +4418,7 @@ const transactionCtx = {
     if (store?.rollbackCallbacks) {
       store.rollbackCallbacks.push(cb);
     }
-  }
+  },
 };
 const createQueryBuilder = (uid, db, initialState = {}) => {
   const meta = db.metadata.get(uid);
@@ -3982,7 +4447,7 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
       decrements: [],
       aliasCounter: 0,
       filters: null,
-      search: null
+      search: null,
     },
     initialState
   );
@@ -4000,11 +4465,16 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
     },
     select(args) {
       state.type = "select";
-      state.select = ___default.default.uniq(___default.default.castArray(args));
+      state.select = ___default.default.uniq(
+        ___default.default.castArray(args)
+      );
       return this;
     },
     addSelect(args) {
-      state.select = ___default.default.uniq([...state.select, ...___default.default.castArray(args)]);
+      state.select = ___default.default.uniq([
+        ...state.select,
+        ...___default.default.castArray(args),
+      ]);
       return this;
     },
     insert(data) {
@@ -4096,7 +4566,17 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
       return this;
     },
     init(params = {}) {
-      const { _q, filters, where, select, limit, offset, orderBy, groupBy, populate } = params;
+      const {
+        _q,
+        filters,
+        where,
+        select,
+        limit,
+        offset,
+        orderBy,
+        groupBy,
+        populate,
+      } = params;
       if (!___default.default.isNil(where)) {
         this.where(where);
       }
@@ -4148,7 +4628,7 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
           alias: this.alias,
           refAlias: join.alias,
           attributeName: join.targetField,
-          attribute
+          attribute,
         }
       );
       return this;
@@ -4170,12 +4650,17 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
     },
     raw: db.connection.raw.bind(db.connection),
     shouldUseSubQuery() {
-      return ["delete", "update"].includes(state.type) && state.joins.length > 0;
+      return (
+        ["delete", "update"].includes(state.type) && state.joins.length > 0
+      );
     },
     runSubQuery() {
       this.select("id");
       const subQB = this.getKnexQuery();
-      const nestedSubQuery = db.getConnection().select("id").from(subQB.as("subQuery"));
+      const nestedSubQuery = db
+        .getConnection()
+        .select("id")
+        .from(subQB.as("subQuery"));
       const connection = db.getConnection(tableName);
       return connection[state.type]().whereIn("id", nestedSubQuery);
     },
@@ -4197,7 +4682,9 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
       this.processSelect();
     },
     shouldUseDistinct() {
-      return state.joins.length > 0 && ___default.default.isEmpty(state.groupBy);
+      return (
+        state.joins.length > 0 && ___default.default.isEmpty(state.groupBy)
+      );
     },
     processSelect() {
       state.select = state.select.map((field) => {
@@ -4208,17 +4695,25 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
       });
       if (this.shouldUseDistinct()) {
         const joinsOrderByColumns = state.joins.flatMap((join) => {
-          return ___default.default.keys(join.orderBy).map((key) => this.aliasColumn(key, join.alias));
+          return ___default.default
+            .keys(join.orderBy)
+            .map((key) => this.aliasColumn(key, join.alias));
         });
         const orderByColumns = state.orderBy.map(({ column }) => column);
-        state.select = ___default.default.uniq([...joinsOrderByColumns, ...orderByColumns, ...state.select]);
+        state.select = ___default.default.uniq([
+          ...joinsOrderByColumns,
+          ...orderByColumns,
+          ...state.select,
+        ]);
       }
     },
     getKnexQuery() {
       if (!state.type) {
         this.select("*");
       }
-      const aliasedTableName = this.mustUseAlias() ? `${tableName} as ${this.alias}` : tableName;
+      const aliasedTableName = this.mustUseAlias()
+        ? `${tableName} as ${this.alias}`
+        : tableName;
       const qb = db.getConnection(aliasedTableName);
       if (this.shouldUseSubQuery()) {
         return this.runSubQuery();
@@ -4233,7 +4728,9 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
           break;
         }
         case "count": {
-          const dbColumnName = this.aliasColumn(toColumnName(meta, state.count));
+          const dbColumnName = this.aliasColumn(
+            toColumnName(meta, state.count)
+          );
           if (this.shouldUseDistinct()) {
             qb.countDistinct({ count: dbColumnName });
           } else {
@@ -4248,7 +4745,10 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
         }
         case "insert": {
           qb.insert(state.data);
-          if (db.dialect.useReturning() && ___default.default.has("id", meta.attributes)) {
+          if (
+            db.dialect.useReturning() &&
+            ___default.default.has("id", meta.attributes)
+          ) {
             qb.returning("id");
           }
           break;
@@ -4278,10 +4778,14 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
         qb.forUpdate();
       }
       if (!___default.default.isEmpty(state.increments)) {
-        state.increments.forEach((incr) => qb.increment(incr.column, incr.amount));
+        state.increments.forEach((incr) =>
+          qb.increment(incr.column, incr.amount)
+        );
       }
       if (!___default.default.isEmpty(state.decrements)) {
-        state.decrements.forEach((decr) => qb.decrement(decr.column, decr.amount));
+        state.decrements.forEach((decr) =>
+          qb.decrement(decr.column, decr.amount)
+        );
       }
       if (state.onConflict) {
         if (state.merge) {
@@ -4327,11 +4831,15 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
         }
         const rows = await qb;
         if (state.populate && !___default.default.isNil(rows)) {
-          await applyPopulate(___default.default.castArray(rows), state.populate, {
-            qb: this,
-            uid,
-            db
-          });
+          await applyPopulate(
+            ___default.default.castArray(rows),
+            state.populate,
+            {
+              qb: this,
+              uid,
+              db,
+            }
+          );
         }
         let results = rows;
         if (mapResults && state.type === "select") {
@@ -4353,7 +4861,7 @@ const createQueryBuilder = (uid, db, initialState = {}) => {
       throw new DatabaseError(
         `query-builder.stream() has been called with an unsupported query type: "${state.type}"`
       );
-    }
+    },
   };
 };
 const withDefaultPagination = (params) => {
@@ -4361,7 +4869,7 @@ const withDefaultPagination = (params) => {
   return {
     page: Number(page),
     pageSize: Number(pageSize),
-    ...rest
+    ...rest,
   };
 };
 const withOffsetLimit = (params) => {
@@ -4371,7 +4879,7 @@ const withOffsetLimit = (params) => {
   const query = {
     ...rest,
     limit,
-    offset
+    offset,
   };
   return [query, { page, pageSize }];
 };
@@ -4386,14 +4894,14 @@ const createRepository = (uid, db) => {
     findWithCount(params = {}) {
       return Promise.all([
         db.entityManager.findMany(uid, params),
-        db.entityManager.count(uid, params)
+        db.entityManager.count(uid, params),
       ]);
     },
     async findPage(params) {
       const [query, { page, pageSize }] = withOffsetLimit(params);
       const [results, total] = await Promise.all([
         db.entityManager.findMany(uid, query),
-        db.entityManager.count(uid, query)
+        db.entityManager.count(uid, query),
       ]);
       return {
         results,
@@ -4401,8 +4909,8 @@ const createRepository = (uid, db) => {
           page,
           pageSize,
           pageCount: Math.ceil(total / pageSize),
-          total
-        }
+          total,
+        },
       };
     },
     create(params) {
@@ -4435,7 +4943,9 @@ const createRepository = (uid, db) => {
     async updateRelations(id, data) {
       const trx = await db.transaction();
       try {
-        await db.entityManager.updateRelations(uid, id, data, { transaction: trx.get() });
+        await db.entityManager.updateRelations(uid, id, data, {
+          transaction: trx.get(),
+        });
         return await trx.commit();
       } catch (e) {
         await trx.rollback();
@@ -4460,13 +4970,20 @@ const createRepository = (uid, db) => {
       }
       const { attributes } = db.metadata.get(uid);
       const attribute = attributes[field];
-      if (!attribute || attribute.type !== "relation" || !attribute.relation || !["oneToMany", "manyToMany"].includes(attribute.relation)) {
-        throw new Error(`Invalid load. Expected ${field} to be an anyToMany relational attribute`);
+      if (
+        !attribute ||
+        attribute.type !== "relation" ||
+        !attribute.relation ||
+        !["oneToMany", "manyToMany"].includes(attribute.relation)
+      ) {
+        throw new Error(
+          `Invalid load. Expected ${field} to be an anyToMany relational attribute`
+        );
       }
       const [query, { page, pageSize }] = withOffsetLimit(params);
       const [results, { count: total }] = await Promise.all([
         db.entityManager.load(uid, entity, field, query),
-        db.entityManager.load(uid, entity, field, { ...query, count: true })
+        db.entityManager.load(uid, entity, field, { ...query, count: true }),
       ]);
       return {
         results,
@@ -4474,53 +4991,60 @@ const createRepository = (uid, db) => {
           page,
           pageSize,
           pageCount: Math.ceil(total / pageSize),
-          total
-        }
+          total,
+        },
       };
-    }
+    },
   };
 };
-const getMorphToManyRowsLinkedToMorphOne = (rows, {
-  uid,
-  attributeName,
-  typeColumn,
-  db
-}) => rows.filter((row) => {
-  const relatedType = row[typeColumn.name];
-  const field = row.field;
-  const targetAttribute = db.metadata.get(relatedType).attributes[field];
-  return targetAttribute?.target === uid && targetAttribute?.morphBy === attributeName && targetAttribute?.relation === "morphOne";
-});
-const deleteRelatedMorphOneRelationsAfterMorphToManyUpdate = async (rows, {
-  uid,
-  attributeName,
-  joinTable,
-  db,
-  transaction: trx
-}) => {
+const getMorphToManyRowsLinkedToMorphOne = (
+  rows,
+  { uid, attributeName, typeColumn, db }
+) =>
+  rows.filter((row) => {
+    const relatedType = row[typeColumn.name];
+    const field = row.field;
+    const targetAttribute = db.metadata.get(relatedType).attributes[field];
+    return (
+      targetAttribute?.target === uid &&
+      targetAttribute?.morphBy === attributeName &&
+      targetAttribute?.relation === "morphOne"
+    );
+  });
+const deleteRelatedMorphOneRelationsAfterMorphToManyUpdate = async (
+  rows,
+  { uid, attributeName, joinTable, db, transaction: trx }
+) => {
   const { morphColumn } = joinTable;
   const { idColumn, typeColumn } = morphColumn;
   const morphOneRows = getMorphToManyRowsLinkedToMorphOne(rows, {
     uid,
     attributeName,
     typeColumn,
-    db
+    db,
   });
   const groupByType = _.groupBy(typeColumn.name);
   const groupByField = _.groupBy("field");
-  const typeAndFieldIdsGrouped = _.pipe(groupByType, _.mapValues(groupByField))(morphOneRows);
+  const typeAndFieldIdsGrouped = _.pipe(
+    groupByType,
+    _.mapValues(groupByField)
+  )(morphOneRows);
   const orWhere = [];
   for (const [type, v] of Object.entries(typeAndFieldIdsGrouped)) {
     for (const [field, arr] of Object.entries(v)) {
       orWhere.push({
         [typeColumn.name]: type,
         field,
-        [idColumn.name]: { $in: _.map(idColumn.name, arr) }
+        [idColumn.name]: { $in: _.map(idColumn.name, arr) },
       });
     }
   }
   if (!_.isEmpty(orWhere)) {
-    await createQueryBuilder(joinTable.name, db).delete().where({ $or: orWhere }).transacting(trx).execute();
+    await createQueryBuilder(joinTable.name, db)
+      .delete()
+      .where({ $or: orWhere })
+      .transacting(trx)
+      .execute();
   }
 };
 const deletePreviousOneToAnyRelations = async ({
@@ -4528,7 +5052,7 @@ const deletePreviousOneToAnyRelations = async ({
   attribute,
   relIdsToadd,
   db,
-  transaction: trx
+  transaction: trx,
 }) => {
   if (!(isBidirectional(attribute) && isOneToAny(attribute))) {
     throw new Error(
@@ -4537,40 +5061,72 @@ const deletePreviousOneToAnyRelations = async ({
   }
   const { joinTable } = attribute;
   const { joinColumn, inverseJoinColumn } = joinTable;
-  await createQueryBuilder(joinTable.name, db).delete().where({
-    [inverseJoinColumn.name]: relIdsToadd,
-    [joinColumn.name]: { $ne: id }
-  }).where(joinTable.on || {}).transacting(trx).execute();
-  await cleanOrderColumns({ attribute, db, inverseRelIds: relIdsToadd, transaction: trx });
+  await createQueryBuilder(joinTable.name, db)
+    .delete()
+    .where({
+      [inverseJoinColumn.name]: relIdsToadd,
+      [joinColumn.name]: { $ne: id },
+    })
+    .where(joinTable.on || {})
+    .transacting(trx)
+    .execute();
+  await cleanOrderColumns({
+    attribute,
+    db,
+    inverseRelIds: relIdsToadd,
+    transaction: trx,
+  });
 };
 const deletePreviousAnyToOneRelations = async ({
   id,
   attribute,
   relIdToadd,
   db,
-  transaction: trx
+  transaction: trx,
 }) => {
   const { joinTable } = attribute;
   const { joinColumn, inverseJoinColumn } = joinTable;
   if (!isAnyToOne(attribute)) {
-    throw new Error("deletePreviousAnyToOneRelations can only be called for anyToOne relations");
+    throw new Error(
+      "deletePreviousAnyToOneRelations can only be called for anyToOne relations"
+    );
   }
   if (isManyToAny(attribute)) {
-    const relsToDelete = await createQueryBuilder(joinTable.name, db).select(inverseJoinColumn.name).where({
-      [joinColumn.name]: id,
-      [inverseJoinColumn.name]: { $ne: relIdToadd }
-    }).where(joinTable.on || {}).transacting(trx).execute();
+    const relsToDelete = await createQueryBuilder(joinTable.name, db)
+      .select(inverseJoinColumn.name)
+      .where({
+        [joinColumn.name]: id,
+        [inverseJoinColumn.name]: { $ne: relIdToadd },
+      })
+      .where(joinTable.on || {})
+      .transacting(trx)
+      .execute();
     const relIdsToDelete = _.map(inverseJoinColumn.name, relsToDelete);
-    await createQueryBuilder(joinTable.name, db).delete().where({
-      [joinColumn.name]: id,
-      [inverseJoinColumn.name]: { $in: relIdsToDelete }
-    }).where(joinTable.on || {}).transacting(trx).execute();
-    await cleanOrderColumns({ attribute, db, inverseRelIds: relIdsToDelete, transaction: trx });
+    await createQueryBuilder(joinTable.name, db)
+      .delete()
+      .where({
+        [joinColumn.name]: id,
+        [inverseJoinColumn.name]: { $in: relIdsToDelete },
+      })
+      .where(joinTable.on || {})
+      .transacting(trx)
+      .execute();
+    await cleanOrderColumns({
+      attribute,
+      db,
+      inverseRelIds: relIdsToDelete,
+      transaction: trx,
+    });
   } else {
-    await createQueryBuilder(joinTable.name, db).delete().where({
-      [joinColumn.name]: id,
-      [inverseJoinColumn.name]: { $ne: relIdToadd }
-    }).where(joinTable.on || {}).transacting(trx).execute();
+    await createQueryBuilder(joinTable.name, db)
+      .delete()
+      .where({
+        [joinColumn.name]: id,
+        [inverseJoinColumn.name]: { $ne: relIdToadd },
+      })
+      .where(joinTable.on || {})
+      .transacting(trx)
+      .execute();
   }
 };
 const deleteRelations = async ({
@@ -4579,7 +5135,7 @@ const deleteRelations = async ({
   db,
   relIdsToNotDelete = [],
   relIdsToDelete = [],
-  transaction: trx
+  transaction: trx,
 }) => {
   const { joinTable } = attribute;
   const { joinColumn, inverseJoinColumn } = joinTable;
@@ -4589,27 +5145,50 @@ const deleteRelations = async ({
     let done = false;
     const batchSize = 100;
     while (!done) {
-      const batchToDelete = await createQueryBuilder(joinTable.name, db).select(inverseJoinColumn.name).where({
-        [joinColumn.name]: id,
-        id: { $gt: lastId },
-        [inverseJoinColumn.name]: { $notIn: relIdsToNotDelete },
-        ...all ? {} : { [inverseJoinColumn.name]: { $in: relIdsToDelete } }
-      }).where(joinTable.on || {}).orderBy("id").limit(batchSize).transacting(trx).execute();
+      const batchToDelete = await createQueryBuilder(joinTable.name, db)
+        .select(inverseJoinColumn.name)
+        .where({
+          [joinColumn.name]: id,
+          id: { $gt: lastId },
+          [inverseJoinColumn.name]: { $notIn: relIdsToNotDelete },
+          ...(all ? {} : { [inverseJoinColumn.name]: { $in: relIdsToDelete } }),
+        })
+        .where(joinTable.on || {})
+        .orderBy("id")
+        .limit(batchSize)
+        .transacting(trx)
+        .execute();
       done = batchToDelete.length < batchSize;
       lastId = batchToDelete[batchToDelete.length - 1]?.id || 0;
       const batchIds = _.map(inverseJoinColumn.name, batchToDelete);
-      await createQueryBuilder(joinTable.name, db).delete().where({
-        [joinColumn.name]: id,
-        [inverseJoinColumn.name]: { $in: batchIds }
-      }).where(joinTable.on || {}).transacting(trx).execute();
-      await cleanOrderColumns({ attribute, db, id, inverseRelIds: batchIds, transaction: trx });
+      await createQueryBuilder(joinTable.name, db)
+        .delete()
+        .where({
+          [joinColumn.name]: id,
+          [inverseJoinColumn.name]: { $in: batchIds },
+        })
+        .where(joinTable.on || {})
+        .transacting(trx)
+        .execute();
+      await cleanOrderColumns({
+        attribute,
+        db,
+        id,
+        inverseRelIds: batchIds,
+        transaction: trx,
+      });
     }
   } else {
-    await createQueryBuilder(joinTable.name, db).delete().where({
-      [joinColumn.name]: id,
-      [inverseJoinColumn.name]: { $notIn: relIdsToNotDelete },
-      ...all ? {} : { [inverseJoinColumn.name]: { $in: relIdsToDelete } }
-    }).where(joinTable.on || {}).transacting(trx).execute();
+    await createQueryBuilder(joinTable.name, db)
+      .delete()
+      .where({
+        [joinColumn.name]: id,
+        [inverseJoinColumn.name]: { $notIn: relIdsToNotDelete },
+        ...(all ? {} : { [inverseJoinColumn.name]: { $in: relIdsToDelete } }),
+      })
+      .where(joinTable.on || {})
+      .transacting(trx)
+      .execute();
   }
 };
 const cleanOrderColumns = async ({
@@ -4617,71 +5196,106 @@ const cleanOrderColumns = async ({
   attribute,
   db,
   inverseRelIds = [],
-  transaction: trx
+  transaction: trx,
 }) => {
-  if (!(hasOrderColumn(attribute) && id) && !(hasInverseOrderColumn(attribute) && !_.isEmpty(inverseRelIds))) {
+  if (
+    !(hasOrderColumn(attribute) && id) &&
+    !(hasInverseOrderColumn(attribute) && !_.isEmpty(inverseRelIds))
+  ) {
     return;
   }
   if (!strapi.db.dialect.supportsWindowFunctions()) {
-    await cleanOrderColumnsForOldDatabases({ id, attribute, db, inverseRelIds, transaction: trx });
+    await cleanOrderColumnsForOldDatabases({
+      id,
+      attribute,
+      db,
+      inverseRelIds,
+      transaction: trx,
+    });
     return;
   }
   const { joinTable } = attribute;
-  const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } = joinTable;
+  const {
+    joinColumn,
+    inverseJoinColumn,
+    orderColumnName,
+    inverseOrderColumnName,
+  } = joinTable;
   const updateOrderColumn = async () => {
     if (!hasOrderColumn(attribute) || !id) {
       return;
     }
-    const selectRowsToOrder = (joinTableName) => db.connection(joinTableName).select("id").rowNumber("src_order", orderColumnName, joinColumn.name).where(joinColumn.name, id).toSQL();
+    const selectRowsToOrder = (joinTableName) =>
+      db
+        .connection(joinTableName)
+        .select("id")
+        .rowNumber("src_order", orderColumnName, joinColumn.name)
+        .where(joinColumn.name, id)
+        .toSQL();
     switch (strapi.db.dialect.client) {
       case "mysql": {
         const select = selectRowsToOrder(joinTable.name);
-        await db.getConnection().raw(
-          `UPDATE ?? as a, ( ${select.sql} ) AS b
+        await db
+          .getConnection()
+          .raw(
+            `UPDATE ?? as a, ( ${select.sql} ) AS b
             SET ?? = b.src_order
             WHERE b.id = a.id`,
-          [joinTable.name, ...select.bindings, orderColumnName]
-        ).transacting(trx);
+            [joinTable.name, ...select.bindings, orderColumnName]
+          )
+          .transacting(trx);
         break;
       }
       default: {
         const joinTableName = addSchema(db, joinTable.name);
         const select = selectRowsToOrder(joinTableName);
-        await db.connection.raw(
-          `UPDATE ?? as a
+        await db.connection
+          .raw(
+            `UPDATE ?? as a
             SET ?? = b.src_order
             FROM ( ${select.sql} ) AS b
             WHERE b.id = a.id`,
-          [joinTableName, orderColumnName, ...select.bindings]
-        ).transacting(trx);
+            [joinTableName, orderColumnName, ...select.bindings]
+          )
+          .transacting(trx);
       }
     }
   };
   const updateInverseOrderColumn = async () => {
-    if (!hasInverseOrderColumn(attribute) || _.isEmpty(inverseRelIds))
-      return;
-    const selectRowsToOrder = (joinTableName) => db.connection(joinTableName).select("id").rowNumber("inv_order", inverseOrderColumnName, inverseJoinColumn.name).where(inverseJoinColumn.name, "in", inverseRelIds).toSQL();
+    if (!hasInverseOrderColumn(attribute) || _.isEmpty(inverseRelIds)) return;
+    const selectRowsToOrder = (joinTableName) =>
+      db
+        .connection(joinTableName)
+        .select("id")
+        .rowNumber("inv_order", inverseOrderColumnName, inverseJoinColumn.name)
+        .where(inverseJoinColumn.name, "in", inverseRelIds)
+        .toSQL();
     switch (strapi.db.dialect.client) {
       case "mysql": {
         const select = selectRowsToOrder(joinTable.name);
-        await db.getConnection().raw(
-          `UPDATE ?? as a, ( ${select.sql} ) AS b
+        await db
+          .getConnection()
+          .raw(
+            `UPDATE ?? as a, ( ${select.sql} ) AS b
             SET ?? = b.inv_order
             WHERE b.id = a.id`,
-          [joinTable.name, ...select.bindings, inverseOrderColumnName]
-        ).transacting(trx);
+            [joinTable.name, ...select.bindings, inverseOrderColumnName]
+          )
+          .transacting(trx);
         break;
       }
       default: {
         const joinTableName = addSchema(db, joinTable.name);
         const select = selectRowsToOrder(joinTableName);
-        await db.connection.raw(
-          `UPDATE ?? as a
+        await db.connection
+          .raw(
+            `UPDATE ?? as a
             SET ?? = b.inv_order
             FROM ( ${select.sql} ) AS b
             WHERE b.id = a.id`,
-          [joinTableName, inverseOrderColumnName, ...select.bindings]
-        ).transacting(trx);
+            [joinTableName, inverseOrderColumnName, ...select.bindings]
+          )
+          .transacting(trx);
       }
     }
   };
@@ -4692,16 +5306,24 @@ const cleanOrderColumnsForOldDatabases = async ({
   attribute,
   db,
   inverseRelIds,
-  transaction: trx
+  transaction: trx,
 }) => {
   const { joinTable } = attribute;
-  const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } = joinTable;
-  const randomSuffix = `${(/* @__PURE__ */ new Date()).valueOf()}_${crypto.randomBytes(16).toString("hex")}`;
+  const {
+    joinColumn,
+    inverseJoinColumn,
+    orderColumnName,
+    inverseOrderColumnName,
+  } = joinTable;
+  const randomSuffix = `${/* @__PURE__ */ new Date().valueOf()}_${crypto
+    .randomBytes(16)
+    .toString("hex")}`;
   if (hasOrderColumn(attribute) && id) {
     const orderVar = `order_${randomSuffix}`;
     await db.connection.raw(`SET @${orderVar} = 0;`).transacting(trx);
-    await db.connection.raw(
-      `UPDATE :joinTableName: as a, (
+    await db.connection
+      .raw(
+        `UPDATE :joinTableName: as a, (
           SELECT id, (@${orderVar}:=@${orderVar} + 1) AS src_order
           FROM :joinTableName:
 	        WHERE :joinColumnName: = :id
@@ -4710,20 +5332,22 @@ const cleanOrderColumnsForOldDatabases = async ({
         SET :orderColumnName: = b.src_order
         WHERE a.id = b.id
         AND a.:joinColumnName: = :id`,
-      {
-        joinTableName: joinTable.name,
-        orderColumnName,
-        joinColumnName: joinColumn.name,
-        id
-      }
-    ).transacting(trx);
+        {
+          joinTableName: joinTable.name,
+          orderColumnName,
+          joinColumnName: joinColumn.name,
+          id,
+        }
+      )
+      .transacting(trx);
   }
   if (hasInverseOrderColumn(attribute) && !_.isEmpty(inverseRelIds)) {
     const orderVar = `order_${randomSuffix}`;
     const columnVar = `col_${randomSuffix}`;
     await db.connection.raw(`SET @${orderVar} = 0;`).transacting(trx);
-    await db.connection.raw(
-      `UPDATE ?? as a, (
+    await db.connection
+      .raw(
+        `UPDATE ?? as a, (
           SELECT
           	id,
             @${orderVar}:=CASE WHEN @${columnVar} = ?? THEN @${orderVar} + 1 ELSE 1 END AS inv_order,
@@ -4735,44 +5359,63 @@ const cleanOrderColumnsForOldDatabases = async ({
         SET ?? = b.inv_order
         WHERE a.id = b.id
         AND a.?? IN(${inverseRelIds.map(() => "?").join(", ")})`,
-      [
-        joinTable.name,
-        inverseJoinColumn.name,
-        inverseJoinColumn.name,
-        inverseJoinColumn.name,
-        joinTable.name,
-        inverseJoinColumn.name,
-        ...inverseRelIds,
-        inverseJoinColumn.name,
-        joinColumn.name,
-        inverseOrderColumnName,
-        inverseJoinColumn.name,
-        ...inverseRelIds
-      ]
-    ).transacting(trx);
+        [
+          joinTable.name,
+          inverseJoinColumn.name,
+          inverseJoinColumn.name,
+          inverseJoinColumn.name,
+          joinTable.name,
+          inverseJoinColumn.name,
+          ...inverseRelIds,
+          inverseJoinColumn.name,
+          joinColumn.name,
+          inverseOrderColumnName,
+          inverseJoinColumn.name,
+          ...inverseRelIds,
+        ]
+      )
+      .transacting(trx);
   }
 };
-const cleanInverseOrderColumn = async ({
-  id,
-  attribute,
-  trx
-}) => {
+const cleanInverseOrderColumn = async ({ id, attribute, trx }) => {
   const con = strapi.db.connection;
   const { joinTable } = attribute;
   const { joinColumn, inverseJoinColumn, inverseOrderColumnName } = joinTable;
   switch (strapi.db.dialect.client) {
     case "mysql": {
-      const subQuery = con(joinTable.name).select(inverseJoinColumn.name).max(inverseOrderColumnName, { as: "max_inv_order" }).groupBy(inverseJoinColumn.name).as("t2");
-      await con(`${joinTable.name} as t1`).join(subQuery, `t1.${inverseJoinColumn.name}`, "=", `t2.${inverseJoinColumn.name}`).where(joinColumn.name, id).update({
-        [inverseOrderColumnName]: con.raw("t2.max_inv_order + 1")
-      }).transacting(trx);
+      const subQuery = con(joinTable.name)
+        .select(inverseJoinColumn.name)
+        .max(inverseOrderColumnName, { as: "max_inv_order" })
+        .groupBy(inverseJoinColumn.name)
+        .as("t2");
+      await con(`${joinTable.name} as t1`)
+        .join(
+          subQuery,
+          `t1.${inverseJoinColumn.name}`,
+          "=",
+          `t2.${inverseJoinColumn.name}`
+        )
+        .where(joinColumn.name, id)
+        .update({
+          [inverseOrderColumnName]: con.raw("t2.max_inv_order + 1"),
+        })
+        .transacting(trx);
       break;
     }
     default: {
       const joinTableName = addSchema(strapi.db, joinTable.name);
-      const selectMaxInverseOrder = con.raw(`max(${inverseOrderColumnName}) + 1`);
-      const subQuery = con(`${joinTableName} as t2`).select(selectMaxInverseOrder).whereRaw(`t2.${inverseJoinColumn.name} = t1.${inverseJoinColumn.name}`);
-      await con(`${joinTableName} as t1`).where(`t1.${joinColumn.name}`, id).update({ [inverseOrderColumnName]: subQuery }).transacting(trx);
+      const selectMaxInverseOrder = con.raw(
+        `max(${inverseOrderColumnName}) + 1`
+      );
+      const subQuery = con(`${joinTableName} as t2`)
+        .select(selectMaxInverseOrder)
+        .whereRaw(
+          `t2.${inverseJoinColumn.name} = t1.${inverseJoinColumn.name}`
+        );
+      await con(`${joinTableName} as t1`)
+        .where(`t1.${joinColumn.name}`, id)
+        .update({ [inverseOrderColumnName]: subQuery })
+        .transacting(trx);
     }
   }
 };
@@ -4785,7 +5428,10 @@ const sortConnectArray = (connectArr, initialArr = [], strictSort = true) => {
   );
   const mappedRelations = connectArr.reduce((mapper, relation) => {
     const adjacentRelId = relation.position?.before || relation.position?.after;
-    if (!adjacentRelId || !relationInInitialArray[adjacentRelId] && !mapper[adjacentRelId]) {
+    if (
+      !adjacentRelId ||
+      (!relationInInitialArray[adjacentRelId] && !mapper[adjacentRelId])
+    ) {
       needsSorting = true;
     }
     if (mapper[relation.id]) {
@@ -4795,11 +5441,10 @@ const sortConnectArray = (connectArr, initialArr = [], strictSort = true) => {
     }
     return {
       [relation.id]: { ...relation, computed: false },
-      ...mapper
+      ...mapper,
     };
   }, {});
-  if (!needsSorting)
-    return connectArr;
+  if (!needsSorting) return connectArr;
   const computeRelation = (relation, relationsSeenInBranch) => {
     const adjacentRelId = relation.position?.before || relation.position?.after;
     const adjacentRelation = mappedRelations[adjacentRelId];
@@ -4817,11 +5462,16 @@ const sortConnectArray = (connectArr, initialArr = [], strictSort = true) => {
       return;
     }
     if (mappedRelations[adjacentRelId]) {
-      computeRelation(adjacentRelation, { ...relationsSeenInBranch, [relation.id]: true });
+      computeRelation(adjacentRelation, {
+        ...relationsSeenInBranch,
+        [relation.id]: true,
+      });
       sortedConnect.push(relation);
     } else if (strictSort) {
       throw new InvalidRelationError(
-        `There was a problem connecting relation with id ${relation.id} at position ${JSON.stringify(
+        `There was a problem connecting relation with id ${
+          relation.id
+        } at position ${JSON.stringify(
           relation.position
         )}. The relation with id ${adjacentRelId} needs to be connected first.`
       );
@@ -4836,7 +5486,7 @@ const relationsOrderer = (initArr, idColumn, orderColumn, strict) => {
   const computedRelations = _.castArray(initArr ?? []).map((r) => ({
     init: true,
     id: r[idColumn],
-    order: Number(r[orderColumn]) || 1
+    order: Number(r[orderColumn]) || 1,
   }));
   const maxOrder = _.maxBy("order", computedRelations)?.order || 0;
   const findRelation = (id) => {
@@ -4884,13 +5534,19 @@ const relationsOrderer = (initArr, idColumn, orderColumn, strict) => {
       return this;
     },
     connect(relations) {
-      sortConnectArray(_.castArray(relations), computedRelations, strict).forEach((relation) => {
+      sortConnectArray(
+        _.castArray(relations),
+        computedRelations,
+        strict
+      ).forEach((relation) => {
         this.disconnect(relation);
         try {
           insertRelation(relation);
         } catch (err) {
           throw new Error(
-            `There was a problem connecting relation with id ${relation.id} at position ${JSON.stringify(
+            `There was a problem connecting relation with id ${
+              relation.id
+            } at position ${JSON.stringify(
               relation.position
             )}. The list of connect relations is not valid`
           );
@@ -4905,15 +5561,18 @@ const relationsOrderer = (initArr, idColumn, orderColumn, strict) => {
      * Get a map between the relation id and its order
      */
     getOrderMap() {
-      return ___default$1.default(computedRelations).groupBy("order").reduce((acc, relations) => {
-        if (relations[0]?.init)
+      return ___default$1
+        .default(computedRelations)
+        .groupBy("order")
+        .reduce((acc, relations) => {
+          if (relations[0]?.init) return acc;
+          relations.forEach((relation, idx) => {
+            acc[relation.id] =
+              Math.floor(relation.order) + (idx + 1) / (relations.length + 1);
+          });
           return acc;
-        relations.forEach((relation, idx) => {
-          acc[relation.id] = Math.floor(relation.order) + (idx + 1) / (relations.length + 1);
-        });
-        return acc;
-      }, {});
-    }
+        }, {});
+    },
   };
 };
 const replaceRegularRelations = async ({
@@ -4921,20 +5580,33 @@ const replaceRegularRelations = async ({
   sourceId,
   attribute,
   omitIds,
-  transaction: trx
+  transaction: trx,
 }) => {
   const { joinTable } = attribute;
   const { joinColumn, inverseJoinColumn } = joinTable;
-  await strapi.db.entityManager.createQueryBuilder(joinTable.name).update({ [joinColumn.name]: targetId }).where({ [joinColumn.name]: sourceId }).where({ $not: { [inverseJoinColumn.name]: omitIds } }).onConflict([joinColumn.name, inverseJoinColumn.name]).ignore().transacting(trx).execute();
+  await strapi.db.entityManager
+    .createQueryBuilder(joinTable.name)
+    .update({ [joinColumn.name]: targetId })
+    .where({ [joinColumn.name]: sourceId })
+    .where({ $not: { [inverseJoinColumn.name]: omitIds } })
+    .onConflict([joinColumn.name, inverseJoinColumn.name])
+    .ignore()
+    .transacting(trx)
+    .execute();
 };
 const cloneRegularRelations = async ({
   targetId,
   sourceId,
   attribute,
-  transaction: trx
+  transaction: trx,
 }) => {
   const { joinTable } = attribute;
-  const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } = joinTable;
+  const {
+    joinColumn,
+    inverseJoinColumn,
+    orderColumnName,
+    inverseOrderColumnName,
+  } = joinTable;
   const connection = strapi.db.getConnection();
   const columns = [joinColumn.name, inverseJoinColumn.name];
   if (orderColumnName) {
@@ -4946,22 +5618,32 @@ const cloneRegularRelations = async ({
   if (joinTable.on) {
     columns.push(...Object.keys(joinTable.on));
   }
-  const selectStatement = connection.select(
-    // Override joinColumn with the new id
-    { [joinColumn.name]: targetId },
-    ...columns.slice(1)
-  ).where(joinColumn.name, sourceId).from(joinTable.name).toSQL();
-  await strapi.db.entityManager.createQueryBuilder(joinTable.name).insert(
-    strapi.db.connection.raw(
-      `(${columns.join(",")})  ${selectStatement.sql}`,
-      selectStatement.bindings
+  const selectStatement = connection
+    .select(
+      // Override joinColumn with the new id
+      { [joinColumn.name]: targetId },
+      ...columns.slice(1)
     )
-  ).onConflict([joinColumn.name, inverseJoinColumn.name]).ignore().transacting(trx).execute();
+    .where(joinColumn.name, sourceId)
+    .from(joinTable.name)
+    .toSQL();
+  await strapi.db.entityManager
+    .createQueryBuilder(joinTable.name)
+    .insert(
+      strapi.db.connection.raw(
+        `(${columns.join(",")})  ${selectStatement.sql}`,
+        selectStatement.bindings
+      )
+    )
+    .onConflict([joinColumn.name, inverseJoinColumn.name])
+    .ignore()
+    .transacting(trx)
+    .execute();
   if (inverseOrderColumnName) {
     await cleanInverseOrderColumn({
       id: targetId,
       attribute,
-      trx
+      trx,
     });
   }
 };
@@ -4977,40 +5659,51 @@ const toId = (value) => {
 };
 const toIds = (value) => _.castArray(value || []).map(toId);
 const isValidId = (value) => _.isString(value) || _.isInteger(value);
-const isValidObjectId = (value) => isRecord(value) && "id" in value && isValidId(value.id);
+const isValidObjectId = (value) =>
+  isRecord(value) && "id" in value && isValidId(value.id);
 const toIdArray = (data) => {
-  const array = _.castArray(data).filter((datum) => !_.isNil(datum)).map((datum) => {
-    if (isValidId(datum)) {
-      return { id: datum, __pivot: {} };
-    }
-    if (!isValidObjectId(datum)) {
-      throw new Error(`Invalid id, expected a string or integer, got ${datum}`);
-    }
-    return datum;
-  });
+  const array = _.castArray(data)
+    .filter((datum) => !_.isNil(datum))
+    .map((datum) => {
+      if (isValidId(datum)) {
+        return { id: datum, __pivot: {} };
+      }
+      if (!isValidObjectId(datum)) {
+        throw new Error(
+          `Invalid id, expected a string or integer, got ${datum}`
+        );
+      }
+      return datum;
+    });
   return _.uniqWith(_.isEqual, array);
 };
 const toAssocs = (data) => {
-  if (_.isArray(data) || _.isString(data) || _.isNumber(data) || _.isNull(data) || isRecord(data) && "id" in data) {
+  if (
+    _.isArray(data) ||
+    _.isString(data) ||
+    _.isNumber(data) ||
+    _.isNull(data) ||
+    (isRecord(data) && "id" in data)
+  ) {
     return {
-      set: _.isNull(data) ? data : toIdArray(data)
+      set: _.isNull(data) ? data : toIdArray(data),
     };
   }
   if (data?.set) {
     return {
-      set: _.isNull(data.set) ? data.set : toIdArray(data.set)
+      set: _.isNull(data.set) ? data.set : toIdArray(data.set),
     };
   }
   return {
     options: {
-      strict: data?.options?.strict
+      strict: data?.options?.strict,
     },
     connect: toIdArray(data?.connect).map((elm) => ({
       id: elm.id,
       position: elm.position ? elm.position : { end: true },
-      __pivot: elm.__pivot ?? {}
+      __pivot: elm.__pivot ?? {},
     })),
-    disconnect: toIdArray(data?.disconnect)
+    disconnect: toIdArray(data?.disconnect),
   };
 };
 const processData = (metadata, data = {}, { withDefaults = false } = {}) => {
@@ -5030,38 +5723,59 @@ const processData = (metadata, data = {}, { withDefaults = false } = {}) => {
         }
         continue;
       }
-      if ("validate" in field && typeof field.validate === "function" && data[attributeName] !== null) {
+      if (
+        "validate" in field &&
+        typeof field.validate === "function" &&
+        data[attributeName] !== null
+      ) {
         field.validate(data[attributeName]);
       }
-      const val = data[attributeName] === null ? null : field.toDB(data[attributeName]);
+      const val =
+        data[attributeName] === null ? null : field.toDB(data[attributeName]);
       obj[attributeName] = val;
     }
     if (isRelationalAttribute(attribute)) {
-      if ("joinColumn" in attribute && attribute.joinColumn && attribute.owner) {
+      if (
+        "joinColumn" in attribute &&
+        attribute.joinColumn &&
+        attribute.owner
+      ) {
         const joinColumnName = attribute.joinColumn.name;
-        const attrValue = !_.isUndefined(data[attributeName]) ? data[attributeName] : data[joinColumnName];
+        const attrValue = !_.isUndefined(data[attributeName])
+          ? data[attributeName]
+          : data[joinColumnName];
         if (!_.isUndefined(attrValue)) {
           obj[joinColumnName] = attrValue;
         }
         continue;
       }
-      if ("morphColumn" in attribute && attribute.morphColumn && attribute.owner) {
-        const { idColumn, typeColumn, typeField = "__type" } = attribute.morphColumn;
+      if (
+        "morphColumn" in attribute &&
+        attribute.morphColumn &&
+        attribute.owner
+      ) {
+        const {
+          idColumn,
+          typeColumn,
+          typeField = "__type",
+        } = attribute.morphColumn;
         const value = data[attributeName];
         if (value === null) {
           Object.assign(obj, {
             [idColumn.name]: null,
-            [typeColumn.name]: null
+            [typeColumn.name]: null,
           });
           continue;
         }
         if (!_.isUndefined(value)) {
           if (!_.has("id", value) || !_.has(typeField, value)) {
-            throw new Error(`Expects properties ${typeField} an id to make a morph association`);
+            throw new Error(
+              `Expects properties ${typeField} an id to make a morph association`
+            );
           }
           Object.assign(obj, {
             [idColumn.name]: value.id,
-            [typeColumn.name]: value[typeField]
+            [typeColumn.name]: value[typeField],
           });
         }
       }
@@ -5074,7 +5788,10 @@ const createEntityManager = (db) => {
   return {
     async findOne(uid, params) {
       const states = await db.lifecycles.run("beforeFindOne", uid, { params });
-      const result = await this.createQueryBuilder(uid).init(params).first().execute();
+      const result = await this.createQueryBuilder(uid)
+        .init(params)
+        .first()
+        .execute();
       await db.lifecycles.run("afterFindOne", uid, { params, result }, states);
       return result;
     },
@@ -5087,7 +5804,11 @@ const createEntityManager = (db) => {
     },
     async count(uid, params = {}) {
       const states = await db.lifecycles.run("beforeCount", uid, { params });
-      const res = await this.createQueryBuilder(uid).init(_.pick(["_q", "where", "filters"], params)).count().first().execute();
+      const res = await this.createQueryBuilder(uid)
+        .init(_.pick(["_q", "where", "filters"], params))
+        .count()
+        .first()
+        .execute();
       const result = Number(res.count);
       await db.lifecycles.run("afterCount", uid, { params, result }, states);
       return result;
@@ -5100,7 +5821,9 @@ const createEntityManager = (db) => {
         throw new Error("Create expects a data object");
       }
       const dataToInsert = processData(metadata, data, { withDefaults: true });
-      const res = await this.createQueryBuilder(uid).insert(dataToInsert).execute();
+      const res = await this.createQueryBuilder(uid)
+        .insert(dataToInsert)
+        .execute();
       const id = isRecord(res[0]) ? res[0].id : res[0];
       const trx = await strapi.db.transaction();
       try {
@@ -5114,31 +5837,42 @@ const createEntityManager = (db) => {
       const result = await this.findOne(uid, {
         where: { id },
         select: params.select,
-        populate: params.populate
+        populate: params.populate,
       });
       await db.lifecycles.run("afterCreate", uid, { params, result }, states);
       return result;
     },
     // TODO: where do we handle relation processing for many queries ?
     async createMany(uid, params = {}) {
-      const states = await db.lifecycles.run("beforeCreateMany", uid, { params });
+      const states = await db.lifecycles.run("beforeCreateMany", uid, {
+        params,
+      });
       const metadata = db.metadata.get(uid);
       const { data } = params;
       if (!_.isArray(data)) {
         throw new Error("CreateMany expects data to be an array");
       }
-      const dataToInsert = data.map(
-        (datum) => processData(metadata, datum, { withDefaults: true })
+      const dataToInsert = data.map((datum) =>
+        processData(metadata, datum, { withDefaults: true })
       );
       if (_.isEmpty(dataToInsert)) {
         throw new Error("Nothing to insert");
       }
-      const createdEntries = await this.createQueryBuilder(uid).insert(dataToInsert).execute();
+      const createdEntries = await this.createQueryBuilder(uid)
+        .insert(dataToInsert)
+        .execute();
       const result = {
         count: data.length,
-        ids: createdEntries.map((entry) => typeof entry === "object" ? entry?.id : entry)
+        ids: createdEntries.map((entry) =>
+          typeof entry === "object" ? entry?.id : entry
+        ),
       };
-      await db.lifecycles.run("afterCreateMany", uid, { params, result }, states);
+      await db.lifecycles.run(
+        "afterCreateMany",
+        uid,
+        { params, result },
+        states
+      );
       return result;
     },
     async update(uid, params = {}) {
@@ -5151,14 +5885,21 @@ const createEntityManager = (db) => {
       if (_.isEmpty(where)) {
         throw new Error("Update requires a where parameter");
       }
-      const entity = await this.createQueryBuilder(uid).select("*").where(where).first().execute({ mapResults: false });
+      const entity = await this.createQueryBuilder(uid)
+        .select("*")
+        .where(where)
+        .first()
+        .execute({ mapResults: false });
       if (!entity) {
         return null;
       }
       const { id } = entity;
       const dataToUpdate = processData(metadata, data);
       if (!_.isEmpty(dataToUpdate)) {
-        await this.createQueryBuilder(uid).where({ id }).update(dataToUpdate).execute();
+        await this.createQueryBuilder(uid)
+          .where({ id })
+          .update(dataToUpdate)
+          .execute();
       }
       const trx = await strapi.db.transaction();
       try {
@@ -5166,29 +5907,42 @@ const createEntityManager = (db) => {
         await trx.commit();
       } catch (e) {
         await trx.rollback();
-        await this.createQueryBuilder(uid).where({ id }).update(entity).execute();
+        await this.createQueryBuilder(uid)
+          .where({ id })
+          .update(entity)
+          .execute();
         throw e;
       }
       const result = await this.findOne(uid, {
         where: { id },
         select: params.select,
-        populate: params.populate
+        populate: params.populate,
       });
       await db.lifecycles.run("afterUpdate", uid, { params, result }, states);
       return result;
     },
     // TODO: where do we handle relation processing for many queries ?
     async updateMany(uid, params = {}) {
-      const states = await db.lifecycles.run("beforeUpdateMany", uid, { params });
+      const states = await db.lifecycles.run("beforeUpdateMany", uid, {
+        params,
+      });
       const metadata = db.metadata.get(uid);
       const { where, data } = params;
       const dataToUpdate = processData(metadata, data);
       if (_.isEmpty(dataToUpdate)) {
         throw new Error("Update requires data");
       }
-      const updatedRows = await this.createQueryBuilder(uid).where(where).update(dataToUpdate).execute();
+      const updatedRows = await this.createQueryBuilder(uid)
+        .where(where)
+        .update(dataToUpdate)
+        .execute();
       const result = { count: updatedRows };
-      await db.lifecycles.run("afterUpdateMany", uid, { params, result }, states);
+      await db.lifecycles.run(
+        "afterUpdateMany",
+        uid,
+        { params, result },
+        states
+      );
       return result;
     },
     async clone(uid, cloneId, params = {}) {
@@ -5203,24 +5957,36 @@ const createEntityManager = (db) => {
         // Omit unwanted properties
         _.omit(["id", "created_at", "updated_at"]),
         // Merge with provided data, set attribute to null if data attribute is null
-        _.mergeWith(
-          data || {},
-          (original, override) => override === null ? override : original
+        _.mergeWith(data || {}, (original, override) =>
+          override === null ? override : original
         ),
         // Process data with metadata
         (entity2) => processData(metadata, entity2, { withDefaults: true })
       )(entity);
-      const res = await this.createQueryBuilder(uid).insert(dataToInsert).execute();
+      const res = await this.createQueryBuilder(uid)
+        .insert(dataToInsert)
+        .execute();
       const id = isRecord(res[0]) ? res[0].id : res[0];
       const trx = await strapi.db.transaction();
       try {
-        const cloneAttrs = Object.entries(metadata.attributes).reduce((acc, [attrName, attr]) => {
-          if (isRelationalAttribute(attr) && "joinTable" in attr && attr.joinTable && !("component" in attr)) {
-            acc.push(attrName);
-          }
-          return acc;
-        }, []);
-        await this.cloneRelations(uid, id, cloneId, data, { cloneAttrs, transaction: trx.get() });
+        const cloneAttrs = Object.entries(metadata.attributes).reduce(
+          (acc, [attrName, attr]) => {
+            if (
+              isRelationalAttribute(attr) &&
+              "joinTable" in attr &&
+              attr.joinTable &&
+              !("component" in attr)
+            ) {
+              acc.push(attrName);
+            }
+            return acc;
+          },
+          []
+        );
+        await this.cloneRelations(uid, id, cloneId, data, {
+          cloneAttrs,
+          transaction: trx.get(),
+        });
         await trx.commit();
       } catch (e) {
         await trx.rollback();
@@ -5230,7 +5996,7 @@ const createEntityManager = (db) => {
       const result = await this.findOne(uid, {
         where: { id },
         select: params.select,
-        populate: params.populate
+        populate: params.populate,
       });
       await db.lifecycles.run("afterCreate", uid, { params, result }, states);
       return result;
@@ -5244,7 +6010,7 @@ const createEntityManager = (db) => {
       const entity = await this.findOne(uid, {
         select: select && ["id"].concat(select),
         where,
-        populate
+        populate,
       });
       if (!entity) {
         return null;
@@ -5259,16 +6025,31 @@ const createEntityManager = (db) => {
         await trx.rollback();
         throw e;
       }
-      await db.lifecycles.run("afterDelete", uid, { params, result: entity }, states);
+      await db.lifecycles.run(
+        "afterDelete",
+        uid,
+        { params, result: entity },
+        states
+      );
       return entity;
     },
     // TODO: where do we handle relation processing for many queries ?
     async deleteMany(uid, params = {}) {
-      const states = await db.lifecycles.run("beforeDeleteMany", uid, { params });
+      const states = await db.lifecycles.run("beforeDeleteMany", uid, {
+        params,
+      });
       const { where } = params;
-      const deletedRows = await this.createQueryBuilder(uid).where(where).delete().execute();
+      const deletedRows = await this.createQueryBuilder(uid)
+        .where(where)
+        .delete()
+        .execute();
       const result = { count: deletedRows };
-      await db.lifecycles.run("afterDeleteMany", uid, { params, result }, states);
+      await db.lifecycles.run(
+        "afterDeleteMany",
+        uid,
+        { params, result },
+        states
+      );
       return result;
     },
     /**
@@ -5279,12 +6060,16 @@ const createEntityManager = (db) => {
       const { transaction: trx } = options ?? {};
       for (const attributeName of Object.keys(attributes)) {
         const attribute = attributes[attributeName];
-        const isValidLink = _.has(attributeName, data) && !_.isNil(data[attributeName]);
+        const isValidLink =
+          _.has(attributeName, data) && !_.isNil(data[attributeName]);
         if (attribute.type !== "relation" || !isValidLink) {
           continue;
         }
         const cleanRelationData = toAssocs(data[attributeName]);
-        if (attribute.relation === "morphOne" || attribute.relation === "morphMany") {
+        if (
+          attribute.relation === "morphOne" ||
+          attribute.relation === "morphMany"
+        ) {
           const { target, morphBy } = attribute;
           const targetAttribute = db.metadata.get(target).attributes[morphBy];
           if (targetAttribute.type !== "relation") {
@@ -5295,7 +6080,11 @@ const createEntityManager = (db) => {
           if (targetAttribute.relation === "morphToOne") {
             const { idColumn, typeColumn } = targetAttribute.morphColumn;
             const relId = toId(cleanRelationData.set?.[0]);
-            await this.createQueryBuilder(target).update({ [idColumn.name]: id, [typeColumn.name]: uid }).where({ id: relId }).transacting(trx).execute();
+            await this.createQueryBuilder(target)
+              .update({ [idColumn.name]: id, [typeColumn.name]: uid })
+              .where({ id: relId })
+              .transacting(trx)
+              .execute();
           } else if (targetAttribute.relation === "morphToMany") {
             const { joinTable } = targetAttribute;
             const { joinColumn, morphColumn } = joinTable;
@@ -5303,18 +6092,22 @@ const createEntityManager = (db) => {
             if (_.isEmpty(cleanRelationData.set)) {
               continue;
             }
-            const rows = cleanRelationData.set?.map((data2, idx) => {
-              return {
-                [joinColumn.name]: data2.id,
-                [idColumn.name]: id,
-                [typeColumn.name]: uid,
-                ..."on" in joinTable && joinTable.on || {},
-                ...data2.__pivot || {},
-                order: idx + 1,
-                field: attributeName
-              };
-            }) ?? [];
-            await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();
+            const rows =
+              cleanRelationData.set?.map((data2, idx) => {
+                return {
+                  [joinColumn.name]: data2.id,
+                  [idColumn.name]: id,
+                  [typeColumn.name]: uid,
+                  ...(("on" in joinTable && joinTable.on) || {}),
+                  ...(data2.__pivot || {}),
+                  order: idx + 1,
+                  field: attributeName,
+                };
+              }) ?? [];
+            await this.createQueryBuilder(joinTable.name)
+              .insert(rows)
+              .transacting(trx)
+              .execute();
           }
           continue;
         } else if (attribute.relation === "morphToOne") {
@@ -5326,41 +6119,78 @@ const createEntityManager = (db) => {
           if (_.isEmpty(cleanRelationData.set)) {
             continue;
           }
-          const rows = cleanRelationData.set?.map((data2, idx) => ({
-            [joinColumn.name]: id,
-            [idColumn.name]: data2.id,
-            [typeColumn.name]: data2[typeField],
-            ..."on" in joinTable && joinTable.on || {},
-            ...data2.__pivot || {},
-            order: idx + 1
-          })) ?? [];
+          const rows =
+            cleanRelationData.set?.map((data2, idx) => ({
+              [joinColumn.name]: id,
+              [idColumn.name]: data2.id,
+              [typeColumn.name]: data2[typeField],
+              ...(("on" in joinTable && joinTable.on) || {}),
+              ...(data2.__pivot || {}),
+              order: idx + 1,
+            })) ?? [];
           await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rows, {
             uid,
             attributeName,
             joinTable,
             db,
-            transaction: trx
+            transaction: trx,
           });
-          await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();
+          await this.createQueryBuilder(joinTable.name)
+            .insert(rows)
+            .transacting(trx)
+            .execute();
           continue;
         }
-        if ("joinColumn" in attribute && attribute.joinColumn && attribute.owner) {
+        if (
+          "joinColumn" in attribute &&
+          attribute.joinColumn &&
+          attribute.owner
+        ) {
           const relIdsToAdd = toIds(cleanRelationData.set);
-          if (attribute.relation === "oneToOne" && isBidirectional(attribute) && relIdsToAdd.length) {
-            await this.createQueryBuilder(uid).where({ [attribute.joinColumn.name]: relIdsToAdd, id: { $ne: id } }).update({ [attribute.joinColumn.name]: null }).transacting(trx).execute();
+          if (
+            attribute.relation === "oneToOne" &&
+            isBidirectional(attribute) &&
+            relIdsToAdd.length
+          ) {
+            await this.createQueryBuilder(uid)
+              .where({
+                [attribute.joinColumn.name]: relIdsToAdd,
+                id: { $ne: id },
+              })
+              .update({ [attribute.joinColumn.name]: null })
+              .transacting(trx)
+              .execute();
           }
           continue;
         }
-        if ("joinColumn" in attribute && attribute.joinColumn && !attribute.owner) {
+        if (
+          "joinColumn" in attribute &&
+          attribute.joinColumn &&
+          !attribute.owner
+        ) {
           const { target } = attribute;
           const relIdsToAdd = toIds(cleanRelationData.set);
-          await this.createQueryBuilder(target).where({ [attribute.joinColumn.referencedColumn]: id }).update({ [attribute.joinColumn.referencedColumn]: null }).transacting(trx).execute();
-          await this.createQueryBuilder(target).update({ [attribute.joinColumn.referencedColumn]: id }).where({ id: relIdsToAdd }).transacting(trx).execute();
+          await this.createQueryBuilder(target)
+            .where({ [attribute.joinColumn.referencedColumn]: id })
+            .update({ [attribute.joinColumn.referencedColumn]: null })
+            .transacting(trx)
+            .execute();
+          await this.createQueryBuilder(target)
+            .update({ [attribute.joinColumn.referencedColumn]: id })
+            .where({ id: relIdsToAdd })
+            .transacting(trx)
+            .execute();
         }
         if ("joinTable" in attribute && attribute.joinTable) {
           const { joinTable } = attribute;
-          const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } = joinTable;
-          const relsToAdd = (cleanRelationData.set || cleanRelationData.connect) ?? [];
+          const {
+            joinColumn,
+            inverseJoinColumn,
+            orderColumnName,
+            inverseOrderColumnName,
+          } = joinTable;
+          const relsToAdd =
+            (cleanRelationData.set || cleanRelationData.connect) ?? [];
           const relIdsToadd = toIds(relsToAdd);
           if (isBidirectional(attribute) && isOneToAny(attribute)) {
             await deletePreviousOneToAnyRelations({
@@ -5368,15 +6198,15 @@ const createEntityManager = (db) => {
               attribute,
               relIdsToadd,
               db,
-              transaction: trx
+              transaction: trx,
             });
           }
           const insert = _.uniqBy("id", relsToAdd).map((data2) => {
             return {
               [joinColumn.name]: id,
               [inverseJoinColumn.name]: data2.id,
-              ..."on" in joinTable && joinTable.on || {},
-              ...data2.__pivot || {}
+              ...(("on" in joinTable && joinTable.on) || {}),
+              ...(data2.__pivot || {}),
             };
           });
           if (cleanRelationData.set && hasOrderColumn(attribute)) {
@@ -5390,25 +6220,41 @@ const createEntityManager = (db) => {
               joinTable.orderColumnName,
               true
               // Always make an strict connect when inserting
-            ).connect(relsToAdd).get().reduce((acc, rel, idx) => ({ ...acc, [rel.id]: idx }), {});
+            )
+              .connect(relsToAdd)
+              .get()
+              .reduce((acc, rel, idx) => ({ ...acc, [rel.id]: idx }), {});
             insert.forEach((row) => {
               row[orderColumnName] = orderMap[row[inverseJoinColumn.name]];
             });
           }
           if (hasInverseOrderColumn(attribute)) {
-            const maxResults = await db.getConnection().select(inverseJoinColumn.name).max(inverseOrderColumnName, { as: "max" }).whereIn(inverseJoinColumn.name, relIdsToadd).where(joinTable.on || {}).groupBy(inverseJoinColumn.name).from(joinTable.name).transacting(trx);
+            const maxResults = await db
+              .getConnection()
+              .select(inverseJoinColumn.name)
+              .max(inverseOrderColumnName, { as: "max" })
+              .whereIn(inverseJoinColumn.name, relIdsToadd)
+              .where(joinTable.on || {})
+              .groupBy(inverseJoinColumn.name)
+              .from(joinTable.name)
+              .transacting(trx);
             const maxMap = maxResults.reduce(
-              (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),
+              (acc, res) =>
+                Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),
               {}
             );
             insert.forEach((rel) => {
-              rel[inverseOrderColumnName] = (maxMap[rel[inverseJoinColumn.name]] || 0) + 1;
+              rel[inverseOrderColumnName] =
+                (maxMap[rel[inverseJoinColumn.name]] || 0) + 1;
             });
           }
           if (insert.length === 0) {
             continue;
           }
-          await this.createQueryBuilder(joinTable.name).insert(insert).transacting(trx).execute();
+          await this.createQueryBuilder(joinTable.name)
+            .insert(insert)
+            .transacting(trx)
+            .execute();
         }
       }
     },
@@ -5425,26 +6271,47 @@ const createEntityManager = (db) => {
           continue;
         }
         const cleanRelationData = toAssocs(data[attributeName]);
-        if (attribute.relation === "morphOne" || attribute.relation === "morphMany") {
+        if (
+          attribute.relation === "morphOne" ||
+          attribute.relation === "morphMany"
+        ) {
           const { target, morphBy } = attribute;
           const targetAttribute = db.metadata.get(target).attributes[morphBy];
-          if (targetAttribute.type === "relation" && targetAttribute.relation === "morphToOne") {
+          if (
+            targetAttribute.type === "relation" &&
+            targetAttribute.relation === "morphToOne"
+          ) {
             const { idColumn, typeColumn } = targetAttribute.morphColumn;
-            await this.createQueryBuilder(target).update({ [idColumn.name]: null, [typeColumn.name]: null }).where({ [idColumn.name]: id, [typeColumn.name]: uid }).transacting(trx).execute();
+            await this.createQueryBuilder(target)
+              .update({ [idColumn.name]: null, [typeColumn.name]: null })
+              .where({ [idColumn.name]: id, [typeColumn.name]: uid })
+              .transacting(trx)
+              .execute();
             if (!_.isNull(cleanRelationData.set)) {
               const relId = toIds(cleanRelationData.set?.[0]);
-              await this.createQueryBuilder(target).update({ [idColumn.name]: id, [typeColumn.name]: uid }).where({ id: relId }).transacting(trx).execute();
+              await this.createQueryBuilder(target)
+                .update({ [idColumn.name]: id, [typeColumn.name]: uid })
+                .where({ id: relId })
+                .transacting(trx)
+                .execute();
             }
-          } else if (targetAttribute.type === "relation" && targetAttribute.relation === "morphToMany") {
+          } else if (
+            targetAttribute.type === "relation" &&
+            targetAttribute.relation === "morphToMany"
+          ) {
             const { joinTable } = targetAttribute;
             const { joinColumn, morphColumn } = joinTable;
             const { idColumn, typeColumn } = morphColumn;
-            await this.createQueryBuilder(joinTable.name).delete().where({
-              [idColumn.name]: id,
-              [typeColumn.name]: uid,
-              ...joinTable.on || {},
-              field: attributeName
-            }).transacting(trx).execute();
+            await this.createQueryBuilder(joinTable.name)
+              .delete()
+              .where({
+                [idColumn.name]: id,
+                [typeColumn.name]: uid,
+                ...(joinTable.on || {}),
+                field: attributeName,
+              })
+              .transacting(trx)
+              .execute();
             if (_.isEmpty(cleanRelationData.set)) {
               continue;
             }
@@ -5452,12 +6319,15 @@ const createEntityManager = (db) => {
               [joinColumn.name]: data2.id,
               [idColumn.name]: id,
               [typeColumn.name]: uid,
-              ...joinTable.on || {},
-              ...data2.__pivot || {},
+              ...(joinTable.on || {}),
+              ...(data2.__pivot || {}),
               order: idx + 1,
-              field: attributeName
+              field: attributeName,
             }));
-            await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();
+            await this.createQueryBuilder(joinTable.name)
+              .insert(rows)
+              .transacting(trx)
+              .execute();
           }
           continue;
         }
@@ -5468,10 +6338,14 @@ const createEntityManager = (db) => {
           const { joinTable } = attribute;
           const { joinColumn, morphColumn } = joinTable;
           const { idColumn, typeColumn, typeField = "__type" } = morphColumn;
-          await this.createQueryBuilder(joinTable.name).delete().where({
-            [joinColumn.name]: id,
-            ...joinTable.on || {}
-          }).transacting(trx).execute();
+          await this.createQueryBuilder(joinTable.name)
+            .delete()
+            .where({
+              [joinColumn.name]: id,
+              ...(joinTable.on || {}),
+            })
+            .transacting(trx)
+            .execute();
           if (_.isEmpty(cleanRelationData.set)) {
             continue;
           }
@@ -5479,34 +6353,58 @@ const createEntityManager = (db) => {
             [joinColumn.name]: id,
             [idColumn.name]: data2.id,
             [typeColumn.name]: data2[typeField],
-            ...joinTable.on || {},
-            ...data2.__pivot || {},
-            order: idx + 1
+            ...(joinTable.on || {}),
+            ...(data2.__pivot || {}),
+            order: idx + 1,
           }));
           await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rows, {
             uid,
             attributeName,
             joinTable,
             db,
-            transaction: trx
+            transaction: trx,
           });
-          await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();
+          await this.createQueryBuilder(joinTable.name)
+            .insert(rows)
+            .transacting(trx)
+            .execute();
           continue;
         }
-        if ("joinColumn" in attribute && attribute.joinColumn && attribute.owner) {
+        if (
+          "joinColumn" in attribute &&
+          attribute.joinColumn &&
+          attribute.owner
+        ) {
           continue;
         }
-        if ("joinColumn" in attribute && attribute.joinColumn && !attribute.owner) {
+        if (
+          "joinColumn" in attribute &&
+          attribute.joinColumn &&
+          !attribute.owner
+        ) {
           const { target } = attribute;
-          await this.createQueryBuilder(target).where({ [attribute.joinColumn.referencedColumn]: id }).update({ [attribute.joinColumn.referencedColumn]: null }).transacting(trx).execute();
+          await this.createQueryBuilder(target)
+            .where({ [attribute.joinColumn.referencedColumn]: id })
+            .update({ [attribute.joinColumn.referencedColumn]: null })
+            .transacting(trx)
+            .execute();
           if (!_.isNull(cleanRelationData.set)) {
             const relIdsToAdd = toIds(cleanRelationData.set);
-            await this.createQueryBuilder(target).where({ id: relIdsToAdd }).update({ [attribute.joinColumn.referencedColumn]: id }).transacting(trx).execute();
+            await this.createQueryBuilder(target)
+              .where({ id: relIdsToAdd })
+              .update({ [attribute.joinColumn.referencedColumn]: id })
+              .transacting(trx)
+              .execute();
           }
         }
         if (attribute.joinTable) {
           const { joinTable } = attribute;
-          const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } = joinTable;
+          const {
+            joinColumn,
+            inverseJoinColumn,
+            orderColumnName,
+            inverseOrderColumnName,
+          } = joinTable;
           const select = [joinColumn.name, inverseJoinColumn.name];
           if (hasOrderColumn(attribute)) {
             select.push(orderColumnName);
@@ -5515,13 +6413,20 @@ const createEntityManager = (db) => {
             select.push(inverseOrderColumnName);
           }
           if (_.isNull(cleanRelationData.set)) {
-            await deleteRelations({ id, attribute, db, relIdsToDelete: "all", transaction: trx });
+            await deleteRelations({
+              id,
+              attribute,
+              db,
+              relIdsToDelete: "all",
+              transaction: trx,
+            });
           } else {
             const isPartialUpdate = !_.has("set", cleanRelationData);
             let relIdsToaddOrMove;
             if (isPartialUpdate) {
               if (isAnyToOne(attribute)) {
-                cleanRelationData.connect = cleanRelationData.connect?.slice(-1);
+                cleanRelationData.connect =
+                  cleanRelationData.connect?.slice(-1);
               }
               relIdsToaddOrMove = toIds(cleanRelationData.connect);
               const relIdsToDelete = toIds(
@@ -5532,49 +6437,82 @@ const createEntityManager = (db) => {
                 )
               );
               if (!_.isEmpty(relIdsToDelete)) {
-                await deleteRelations({ id, attribute, db, relIdsToDelete, transaction: trx });
+                await deleteRelations({
+                  id,
+                  attribute,
+                  db,
+                  relIdsToDelete,
+                  transaction: trx,
+                });
               }
               if (_.isEmpty(cleanRelationData.connect)) {
                 continue;
               }
               let currentMovingRels = [];
-              if (hasOrderColumn(attribute) || hasInverseOrderColumn(attribute)) {
-                currentMovingRels = await this.createQueryBuilder(joinTable.name).select(select).where({
-                  [joinColumn.name]: id,
-                  [inverseJoinColumn.name]: { $in: relIdsToaddOrMove }
-                }).where(joinTable.on || {}).transacting(trx).execute();
+              if (
+                hasOrderColumn(attribute) ||
+                hasInverseOrderColumn(attribute)
+              ) {
+                currentMovingRels = await this.createQueryBuilder(
+                  joinTable.name
+                )
+                  .select(select)
+                  .where({
+                    [joinColumn.name]: id,
+                    [inverseJoinColumn.name]: { $in: relIdsToaddOrMove },
+                  })
+                  .where(joinTable.on || {})
+                  .transacting(trx)
+                  .execute();
               }
-              const insert = _.uniqBy("id", cleanRelationData.connect).map((relToAdd) => ({
-                [joinColumn.name]: id,
-                [inverseJoinColumn.name]: relToAdd.id,
-                ...joinTable.on || {},
-                ...relToAdd.__pivot || {}
-              }));
+              const insert = _.uniqBy("id", cleanRelationData.connect).map(
+                (relToAdd) => ({
+                  [joinColumn.name]: id,
+                  [inverseJoinColumn.name]: relToAdd.id,
+                  ...(joinTable.on || {}),
+                  ...(relToAdd.__pivot || {}),
+                })
+              );
               if (hasOrderColumn(attribute)) {
-                const adjacentRelations = await this.createQueryBuilder(joinTable.name).where({
-                  $or: [
-                    {
-                      [joinColumn.name]: id,
-                      [inverseJoinColumn.name]: {
-                        $in: _.compact(
-                          cleanRelationData.connect?.map(
-                            (r) => r.position?.after || r.position?.before
-                          )
+                const adjacentRelations = await this.createQueryBuilder(
+                  joinTable.name
+                )
+                  .where({
+                    $or: [
+                      {
+                        [joinColumn.name]: id,
+                        [inverseJoinColumn.name]: {
+                          $in: _.compact(
+                            cleanRelationData.connect?.map(
+                              (r) => r.position?.after || r.position?.before
+                            )
+                          ),
+                        },
+                      },
+                      {
+                        [joinColumn.name]: id,
+                        [orderColumnName]: this.createQueryBuilder(
+                          joinTable.name
                         )
-                      }
-                    },
-                    {
-                      [joinColumn.name]: id,
-                      [orderColumnName]: this.createQueryBuilder(joinTable.name).max(orderColumnName).where({ [joinColumn.name]: id }).where(joinTable.on || {}).transacting(trx).getKnexQuery()
-                    }
-                  ]
-                }).where(joinTable.on || {}).transacting(trx).execute();
+                          .max(orderColumnName)
+                          .where({ [joinColumn.name]: id })
+                          .where(joinTable.on || {})
+                          .transacting(trx)
+                          .getKnexQuery(),
+                      },
+                    ],
+                  })
+                  .where(joinTable.on || {})
+                  .transacting(trx)
+                  .execute();
                 const orderMap = relationsOrderer(
                   adjacentRelations,
                   inverseJoinColumn.name,
                   joinTable.orderColumnName,
                   cleanRelationData.options?.strict
-                ).connect(cleanRelationData.connect ?? []).getOrderMap();
+                )
+                  .connect(cleanRelationData.connect ?? [])
+                  .getOrderMap();
                 insert.forEach((row) => {
                   row[orderColumnName] = orderMap[row[inverseJoinColumn.name]];
                 });
@@ -5584,16 +6522,31 @@ const createEntityManager = (db) => {
                   relIdsToaddOrMove,
                   _.map(inverseJoinColumn.name, currentMovingRels)
                 );
-                const maxResults = await db.getConnection().select(inverseJoinColumn.name).max(inverseOrderColumnName, { as: "max" }).whereIn(inverseJoinColumn.name, nonExistingRelsIds).where(joinTable.on || {}).groupBy(inverseJoinColumn.name).from(joinTable.name).transacting(trx);
+                const maxResults = await db
+                  .getConnection()
+                  .select(inverseJoinColumn.name)
+                  .max(inverseOrderColumnName, { as: "max" })
+                  .whereIn(inverseJoinColumn.name, nonExistingRelsIds)
+                  .where(joinTable.on || {})
+                  .groupBy(inverseJoinColumn.name)
+                  .from(joinTable.name)
+                  .transacting(trx);
                 const maxMap = maxResults.reduce(
-                  (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),
+                  (acc, res) =>
+                    Object.assign(acc, {
+                      [res[inverseJoinColumn.name]]: res.max,
+                    }),
                   {}
                 );
                 insert.forEach((row) => {
-                  row[inverseOrderColumnName] = (maxMap[row[inverseJoinColumn.name]] || 0) + 1;
+                  row[inverseOrderColumnName] =
+                    (maxMap[row[inverseJoinColumn.name]] || 0) + 1;
                 });
               }
-              const query = this.createQueryBuilder(joinTable.name).insert(insert).onConflict(joinTable.pivotColumns).transacting(trx);
+              const query = this.createQueryBuilder(joinTable.name)
+                .insert(insert)
+                .onConflict(joinTable.pivotColumns)
+                .transacting(trx);
               if (hasOrderColumn(attribute)) {
                 query.merge([orderColumnName]);
               } else {
@@ -5612,39 +6565,69 @@ const createEntityManager = (db) => {
                 db,
                 relIdsToDelete: "all",
                 relIdsToNotDelete: relIdsToaddOrMove,
-                transaction: trx
+                transaction: trx,
               });
               if (_.isEmpty(cleanRelationData.set)) {
                 continue;
               }
-              const insert = _.uniqBy("id", cleanRelationData.set).map((relToAdd) => ({
-                [joinColumn.name]: id,
-                [inverseJoinColumn.name]: relToAdd.id,
-                ...joinTable.on || {},
-                ...relToAdd.__pivot || {}
-              }));
+              const insert = _.uniqBy("id", cleanRelationData.set).map(
+                (relToAdd) => ({
+                  [joinColumn.name]: id,
+                  [inverseJoinColumn.name]: relToAdd.id,
+                  ...(joinTable.on || {}),
+                  ...(relToAdd.__pivot || {}),
+                })
+              );
               if (hasOrderColumn(attribute)) {
                 insert.forEach((row, idx) => {
                   row[orderColumnName] = idx + 1;
                 });
               }
               if (hasInverseOrderColumn(attribute)) {
-                const existingRels = await this.createQueryBuilder(joinTable.name).select(inverseJoinColumn.name).where({
-                  [joinColumn.name]: id,
-                  [inverseJoinColumn.name]: { $in: relIdsToaddOrMove }
-                }).where(joinTable.on || {}).transacting(trx).execute();
-                const inverseRelsIds = _.map(inverseJoinColumn.name, existingRels);
-                const nonExistingRelsIds = _.difference(relIdsToaddOrMove, inverseRelsIds);
-                const maxResults = await db.getConnection().select(inverseJoinColumn.name).max(inverseOrderColumnName, { as: "max" }).whereIn(inverseJoinColumn.name, nonExistingRelsIds).where(joinTable.on || {}).groupBy(inverseJoinColumn.name).from(joinTable.name).transacting(trx);
+                const existingRels = await this.createQueryBuilder(
+                  joinTable.name
+                )
+                  .select(inverseJoinColumn.name)
+                  .where({
+                    [joinColumn.name]: id,
+                    [inverseJoinColumn.name]: { $in: relIdsToaddOrMove },
+                  })
+                  .where(joinTable.on || {})
+                  .transacting(trx)
+                  .execute();
+                const inverseRelsIds = _.map(
+                  inverseJoinColumn.name,
+                  existingRels
+                );
+                const nonExistingRelsIds = _.difference(
+                  relIdsToaddOrMove,
+                  inverseRelsIds
+                );
+                const maxResults = await db
+                  .getConnection()
+                  .select(inverseJoinColumn.name)
+                  .max(inverseOrderColumnName, { as: "max" })
+                  .whereIn(inverseJoinColumn.name, nonExistingRelsIds)
+                  .where(joinTable.on || {})
+                  .groupBy(inverseJoinColumn.name)
+                  .from(joinTable.name)
+                  .transacting(trx);
                 const maxMap = maxResults.reduce(
-                  (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),
+                  (acc, res) =>
+                    Object.assign(acc, {
+                      [res[inverseJoinColumn.name]]: res.max,
+                    }),
                   {}
                 );
                 insert.forEach((row) => {
-                  row[inverseOrderColumnName] = (maxMap[row[inverseJoinColumn.name]] || 0) + 1;
+                  row[inverseOrderColumnName] =
+                    (maxMap[row[inverseJoinColumn.name]] || 0) + 1;
                 });
               }
-              const query = this.createQueryBuilder(joinTable.name).insert(insert).onConflict(joinTable.pivotColumns).transacting(trx);
+              const query = this.createQueryBuilder(joinTable.name)
+                .insert(insert)
+                .onConflict(joinTable.pivotColumns)
+                .transacting(trx);
               if (hasOrderColumn(attribute)) {
                 query.merge([orderColumnName]);
               } else {
@@ -5658,7 +6641,7 @@ const createEntityManager = (db) => {
                 attribute,
                 relIdsToadd: relIdsToaddOrMove,
                 db,
-                transaction: trx
+                transaction: trx,
               });
             }
             if (isAnyToOne(attribute)) {
@@ -5667,7 +6650,7 @@ const createEntityManager = (db) => {
                 attribute,
                 relIdToadd: relIdsToaddOrMove[0],
                 db,
-                transaction: trx
+                transaction: trx,
               });
             }
           }
@@ -5691,48 +6674,86 @@ const createEntityManager = (db) => {
         if (attribute.type !== "relation") {
           continue;
         }
-        if (attribute.relation === "morphOne" || attribute.relation === "morphMany") {
+        if (
+          attribute.relation === "morphOne" ||
+          attribute.relation === "morphMany"
+        ) {
           const { target, morphBy } = attribute;
           const targetAttribute = db.metadata.get(target).attributes[morphBy];
-          if (targetAttribute.type === "relation" && targetAttribute.relation === "morphToOne") {
+          if (
+            targetAttribute.type === "relation" &&
+            targetAttribute.relation === "morphToOne"
+          ) {
             const { idColumn, typeColumn } = targetAttribute.morphColumn;
-            await this.createQueryBuilder(target).update({ [idColumn.name]: null, [typeColumn.name]: null }).where({ [idColumn.name]: id, [typeColumn.name]: uid }).transacting(trx).execute();
-          } else if (targetAttribute.type === "relation" && targetAttribute.relation === "morphToMany") {
+            await this.createQueryBuilder(target)
+              .update({ [idColumn.name]: null, [typeColumn.name]: null })
+              .where({ [idColumn.name]: id, [typeColumn.name]: uid })
+              .transacting(trx)
+              .execute();
+          } else if (
+            targetAttribute.type === "relation" &&
+            targetAttribute.relation === "morphToMany"
+          ) {
             const { joinTable } = targetAttribute;
             const { morphColumn } = joinTable;
             const { idColumn, typeColumn } = morphColumn;
-            await this.createQueryBuilder(joinTable.name).delete().where({
-              [idColumn.name]: id,
-              [typeColumn.name]: uid,
-              ...joinTable.on || {},
-              field: attributeName
-            }).transacting(trx).execute();
+            await this.createQueryBuilder(joinTable.name)
+              .delete()
+              .where({
+                [idColumn.name]: id,
+                [typeColumn.name]: uid,
+                ...(joinTable.on || {}),
+                field: attributeName,
+              })
+              .transacting(trx)
+              .execute();
           }
           continue;
         }
-        if (attribute.relation === "morphToOne")
-          ;
+        if (attribute.relation === "morphToOne");
         if (attribute.relation === "morphToMany") {
           const { joinTable } = attribute;
           const { joinColumn } = joinTable;
-          await this.createQueryBuilder(joinTable.name).delete().where({
-            [joinColumn.name]: id,
-            ...joinTable.on || {}
-          }).transacting(trx).execute();
+          await this.createQueryBuilder(joinTable.name)
+            .delete()
+            .where({
+              [joinColumn.name]: id,
+              ...(joinTable.on || {}),
+            })
+            .transacting(trx)
+            .execute();
           continue;
         }
         if (db.dialect.usesForeignKeys()) {
           return;
         }
-        if ("joinColumn" in attribute && attribute.joinColumn && attribute.owner) {
+        if (
+          "joinColumn" in attribute &&
+          attribute.joinColumn &&
+          attribute.owner
+        ) {
           continue;
         }
-        if ("joinColumn" in attribute && attribute.joinColumn && !attribute.owner) {
+        if (
+          "joinColumn" in attribute &&
+          attribute.joinColumn &&
+          !attribute.owner
+        ) {
           const { target } = attribute;
-          await this.createQueryBuilder(target).where({ [attribute.joinColumn.referencedColumn]: id }).update({ [attribute.joinColumn.referencedColumn]: null }).transacting(trx).execute();
+          await this.createQueryBuilder(target)
+            .where({ [attribute.joinColumn.referencedColumn]: id })
+            .update({ [attribute.joinColumn.referencedColumn]: null })
+            .transacting(trx)
+            .execute();
         }
         if ("joinTable" in attribute && attribute.joinTable) {
-          await deleteRelations({ id, attribute, db, relIdsToDelete: "all", transaction: trx });
+          await deleteRelations({
+            id,
+            attribute,
+            db,
+            relIdsToDelete: "all",
+            transaction: trx,
+          });
         }
       }
     },
@@ -5781,9 +6802,20 @@ const createEntityManager = (db) => {
           }
         }
         if (isOneToAny(attribute) && isBidirectional(attribute)) {
-          await replaceRegularRelations({ targetId, sourceId, attribute, omitIds, transaction });
+          await replaceRegularRelations({
+            targetId,
+            sourceId,
+            attribute,
+            omitIds,
+            transaction,
+          });
         } else {
-          await cloneRegularRelations({ targetId, sourceId, attribute, transaction });
+          await cloneRegularRelations({
+            targetId,
+            sourceId,
+            attribute,
+            transaction,
+          });
         }
       });
       await this.updateRelations(uid, targetId, data, { transaction });
@@ -5793,7 +6825,7 @@ const createEntityManager = (db) => {
       const entry = await this.findOne(uid, {
         select: ["id"],
         where: { id: entity.id },
-        populate
+        populate,
       });
       return { ...entity, ...entry };
     },
@@ -5804,7 +6836,9 @@ const createEntityManager = (db) => {
       fieldsArr.forEach((field) => {
         const attribute = attributes[field];
         if (!attribute || attribute.type !== "relation") {
-          throw new Error(`Invalid load. Expected ${field} to be a relational attribute`);
+          throw new Error(
+            `Invalid load. Expected ${field} to be a relational attribute`
+          );
         }
       });
       const entry = await this.findOne(uid, {
@@ -5813,7 +6847,7 @@ const createEntityManager = (db) => {
         populate: fieldsArr.reduce((acc, field) => {
           acc[field] = populate || true;
           return acc;
-        }, {})
+        }, {}),
       });
       if (!entry) {
         return null;
@@ -5845,7 +6879,7 @@ const createEntityManager = (db) => {
         repoMap[uid] = createRepository(uid, db);
       }
       return repoMap[uid];
-    }
+    },
   };
 };
 const createStorage = (opts) => {
@@ -5860,22 +6894,29 @@ const createStorage = (opts) => {
   };
   return {
     async logMigration({ name }) {
-      await db.getConnection().insert({
-        name,
-        time: /* @__PURE__ */ new Date()
-      }).into(tableName);
+      await db
+        .getConnection()
+        .insert({
+          name,
+          time: /* @__PURE__ */ new Date(),
+        })
+        .into(tableName);
     },
     async unlogMigration({ name }) {
       await db.getConnection(tableName).del().where({ name });
     },
     async executed() {
-      if (!await hasMigrationTable()) {
+      if (!(await hasMigrationTable())) {
         await createMigrationTable();
         return [];
       }
-      const logs = await db.getConnection(tableName).select().from(tableName).orderBy("time");
+      const logs = await db
+        .getConnection(tableName)
+        .select()
+        .from(tableName)
+        .orderBy("time");
       return logs.map((log) => log.name);
-    }
+    },
   };
 };
 const wrapTransaction = (db) => (fn) => () => {
@@ -5893,18 +6934,21 @@ const migrationResolver = ({ name, path: path2, context }) => {
       up: wrapTransaction(db)((knex2) => knex2.raw(sql)),
       async down() {
         throw new Error("Down migration is not supported for sql files");
-      }
+      },
     };
   }
   const migration = require(path2);
   return {
     name,
     up: wrapTransaction(db)(migration.up),
-    down: wrapTransaction(db)(migration.down)
+    down: wrapTransaction(db)(migration.down),
   };
 };
 const createUmzugProvider = (db) => {
-  const migrationDir = path__default$1.default.join(strapi.dirs.app.root, "database/migrations");
+  const migrationDir = path__default$1.default.join(
+    strapi.dirs.app.root,
+    "database/migrations"
+  );
   fse__default.default.ensureDirSync(migrationDir);
   return new umzug.Umzug({
     storage: createStorage({ db, tableName: "strapi_migrations" }),
@@ -5912,8 +6956,8 @@ const createUmzugProvider = (db) => {
     context: { db },
     migrations: {
       glob: ["*.{js,sql}", { cwd: migrationDir }],
-      resolve: migrationResolver
-    }
+      resolve: migrationResolver,
+    },
   });
 };
 const createMigrationsProvider = (db) => {
@@ -5928,7 +6972,7 @@ const createMigrationsProvider = (db) => {
     },
     async down() {
       await migrations.down();
-    }
+    },
   };
 };
 const modelsLifecyclesSubscriber = async (event) => {
@@ -5954,7 +6998,9 @@ const timestampsLifecyclesSubscriber = {
     const { data } = event.params;
     const now = /* @__PURE__ */ new Date();
     if (___default$1.default.isArray(data)) {
-      data.forEach((data2) => ___default$1.default.defaults(data2, { createdAt: now, updatedAt: now }));
+      data.forEach((data2) =>
+        ___default$1.default.defaults(data2, { createdAt: now, updatedAt: now })
+      );
     }
   },
   /**
@@ -5974,17 +7020,22 @@ const timestampsLifecyclesSubscriber = {
     const { data } = event.params;
     const now = /* @__PURE__ */ new Date();
     if (___default$1.default.isArray(data)) {
-      data.forEach((data2) => ___default$1.default.assign(data2, { updatedAt: now }));
+      data.forEach((data2) =>
+        ___default$1.default.assign(data2, { updatedAt: now })
+      );
     }
-  }
+  },
 };
 const isValidSubscriber = (subscriber) => {
-  return typeof subscriber === "function" || typeof subscriber === "object" && subscriber !== null;
+  return (
+    typeof subscriber === "function" ||
+    (typeof subscriber === "object" && subscriber !== null)
+  );
 };
 const createLifecyclesProvider = (db) => {
   let subscribers = [
     timestampsLifecyclesSubscriber,
-    modelsLifecyclesSubscriber
+    modelsLifecyclesSubscriber,
   ];
   return {
     subscribe(subscriber) {
@@ -6004,7 +7055,7 @@ const createLifecyclesProvider = (db) => {
         action,
         model,
         state,
-        ...properties
+        ...properties,
       };
     },
     /**
@@ -6037,7 +7088,7 @@ const createLifecyclesProvider = (db) => {
         }
       }
       return states;
-    }
+    },
   };
 };
 class LegacySqliteClient extends SqliteClient__default.default {
@@ -6048,14 +7099,18 @@ class LegacySqliteClient extends SqliteClient__default.default {
 const clientMap = {
   "better-sqlite3": "better-sqlite3",
   "@vscode/sqlite3": "sqlite",
-  sqlite3: LegacySqliteClient
+  sqlite3: LegacySqliteClient,
 };
 const trySqlitePackage = (packageName) => {
   try {
     require.resolve(packageName);
     return packageName;
   } catch (error) {
-    if (error instanceof Error && "code" in error && error.code === "MODULE_NOT_FOUND") {
+    if (
+      error instanceof Error &&
+      "code" in error &&
+      error.code === "MODULE_NOT_FOUND"
+    ) {
       return false;
     }
     throw error;
@@ -6065,7 +7120,10 @@ const getSqlitePackageName = () => {
   if (typeof process.env.SQLITE_PKG !== "undefined") {
     return process.env.SQLITE_PKG;
   }
-  const matchingPackage = trySqlitePackage("better-sqlite3") || trySqlitePackage("@vscode/sqlite3") || trySqlitePackage("sqlite3");
+  const matchingPackage =
+    trySqlitePackage("better-sqlite3") ||
+    trySqlitePackage("@vscode/sqlite3") ||
+    trySqlitePackage("sqlite3");
   if (!matchingPackage) {
     throw new Error("No sqlite package found");
   }
@@ -6073,6 +7131,9 @@ const getSqlitePackageName = () => {
 };
 const createConnection = (config) => {
   const knexConfig = { ...config };
+  if (knexConfig.client === "libsql") {
+    knexConfig.client = Client_Libsql;
+  }
   if (knexConfig.client === "sqlite") {
     const sqlitePackageName = getSqlitePackageName();
     knexConfig.client = clientMap[sqlitePackageName];
@@ -6086,7 +7147,7 @@ const transformAttribute = (attribute) => {
         type: "relation",
         relation: attribute.multiple === true ? "morphMany" : "morphOne",
         target: "plugin::upload.file",
-        morphBy: "related"
+        morphBy: "related",
       };
     }
     default: {
@@ -6102,12 +7163,15 @@ const transformContentTypes = (contentTypes) => {
       singularName: contentType.modelName,
       tableName: contentType.collectionName,
       attributes: {
-        ...Object.keys(contentType.attributes || {}).reduce((attrs, attrName) => {
-          return Object.assign(attrs, {
-            [attrName]: transformAttribute(contentType.attributes[attrName])
-          });
-        }, {})
-      }
+        ...Object.keys(contentType.attributes || {}).reduce(
+          (attrs, attrName) => {
+            return Object.assign(attrs, {
+              [attrName]: transformAttribute(contentType.attributes[attrName]),
+            });
+          },
+          {}
+        ),
+      },
     };
     return model;
   });
@@ -6121,11 +7185,13 @@ const getLinksWithoutMappedBy = (db) => {
         return;
       }
       if ("inversedBy" in attribute && attribute.inversedBy) {
-        const invRelation = db.metadata.get(attribute.target).attributes[attribute.inversedBy];
+        const invRelation = db.metadata.get(attribute.target).attributes[
+          attribute.inversedBy
+        ];
         if ("inversedBy" in invRelation && invRelation.inversedBy) {
           relationsToUpdate[attribute.joinTable.name] = {
             relation: attribute,
-            invRelation
+            invRelation,
           };
         }
       }
@@ -6135,9 +7201,11 @@ const getLinksWithoutMappedBy = (db) => {
 };
 const isLinkTableEmpty = async (db, linkTableName) => {
   const exists = await db.getSchemaConnection().hasTable(linkTableName);
-  if (!exists)
-    return true;
-  const result = await db.getConnection().from(linkTableName).count("* as count");
+  if (!exists) return true;
+  const result = await db
+    .getConnection()
+    .from(linkTableName)
+    .count("* as count");
   return Number(result[0].count) === 0;
 };
 const validateBidirectionalRelations = async (db) => {
@@ -6145,10 +7213,19 @@ const validateBidirectionalRelations = async (db) => {
   for (const { relation, invRelation } of invalidLinks) {
     const contentType = db.metadata.get(invRelation.target);
     const invContentType = db.metadata.get(relation.target);
-    const joinTableName = getJoinTableName(contentType.tableName, invRelation.inversedBy);
-    const inverseJoinTableName = getJoinTableName(invContentType.tableName, relation.inversedBy);
+    const joinTableName = getJoinTableName(
+      contentType.tableName,
+      invRelation.inversedBy
+    );
+    const inverseJoinTableName = getJoinTableName(
+      invContentType.tableName,
+      relation.inversedBy
+    );
     const joinTableEmpty = await isLinkTableEmpty(db, joinTableName);
-    const inverseJoinTableEmpty = await isLinkTableEmpty(db, inverseJoinTableName);
+    const inverseJoinTableEmpty = await isLinkTableEmpty(
+      db,
+      inverseJoinTableName
+    );
     if (joinTableEmpty) {
       process.emitWarning(
         `Error on attribute "${invRelation.inversedBy}" in model "${contentType.singularName}" (${contentType.uid}). Please modify your ${contentType.singularName} schema by renaming the key "inversedBy" to "mappedBy". Ex: { "inversedBy": "${relation.inversedBy}" } -> { "mappedBy": "${relation.inversedBy}" }`
@@ -6157,8 +7234,7 @@ const validateBidirectionalRelations = async (db) => {
       process.emitWarning(
         `Error on attribute "${relation.inversedBy}" in model "${invContentType.singularName}" (${invContentType.uid}). Please modify your ${invContentType.singularName} schema by renaming the key "inversedBy" to "mappedBy". Ex: { "inversedBy": "${invRelation.inversedBy}" } -> { "mappedBy": "${invRelation.inversedBy}" }`
       );
-    } else
-      ;
+    } else;
   }
 };
 const validateRelations = async (db) => {
@@ -6189,8 +7265,8 @@ class Database {
       settings: {
         forceMigration: true,
         runMigrations: true,
-        ...config.settings ?? {}
-      }
+        ...(config.settings ?? {}),
+      },
     };
     this.dialect = getDialect(this);
     this.dialect.configure();
@@ -6212,7 +7288,9 @@ class Database {
   }
   async transaction(cb) {
     const notNestedTransaction = !transactionCtx.get();
-    const trx = notNestedTransaction ? await this.connection.transaction() : transactionCtx.get();
+    const trx = notNestedTransaction
+      ? await this.connection.transaction()
+      : transactionCtx.get();
     async function commit() {
       if (notNestedTransaction) {
         await transactionCtx.commit(trx);
@@ -6233,7 +7311,7 @@ class Database {
           commit,
           rollback,
           onCommit: transactionCtx.onCommit,
-          onRollback: transactionCtx.onRollback
+          onRollback: transactionCtx.onRollback,
         };
         const res = await cb(callbackParams);
         await commit();
